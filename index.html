<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Order API Validator</title>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
  <style>
    :root {
      --primary: #3b82f6;
      --primary-dark: #2563eb;
      --warning: #f59e0b;
      --error: #ef4444;
      --success: #10b981;
      --info: #0ea5e9;
      --gray: #e2e8f0;
    }
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: system-ui, -apple-system, sans-serif;
    }
    body {
      background-color: #f8fafc;
      color: #1e293b;
      line-height: 1.5;
      padding: 20px;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
    }
    .mb-4 { margin-bottom: 1rem; }
    .mb-6 { margin-bottom: 1.5rem; }
    .hidden { display: none; }
    .flex { display: flex; }
    .items-center { align-items: center; }
    .justify-between { justify-content: space-between; }
    .justify-center { justify-content: center; }
    .flex-col { flex-direction: column; }
    .gap-2 { gap: 0.5rem; }
    .gap-3 { gap: 0.75rem; }
    .gap-4 { gap: 1rem; }
    .py-1 { padding-top: 0.25rem; padding-bottom: 0.25rem; }
    .py-2 { padding-top: 0.5rem; padding-bottom: 0.5rem; }
    .px-2 { padding-left: 0.5rem; padding-right: 0.5rem; }
    .px-3 { padding-left: 0.75rem; padding-right: 0.75rem; }
    .px-4 { padding-left: 1rem; padding-right: 1rem; }
    .py-4 { padding-top: 1rem; padding-bottom: 1rem; }
    .py-8 { padding-top: 2rem; padding-bottom: 2rem; }
    .px-6 { padding-left: 1.5rem; padding-right: 1.5rem; }
    .py-6 { padding-top: 1.5rem; padding-bottom: 1.5rem; }
    .card {
      background: white;
      border-radius: 0.5rem;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      padding: 1.5rem;
      margin-bottom: 1.5rem;
    }
    .text-center { text-align: center; }
    .text-sm { font-size: 0.875rem; }
    .text-lg { font-size: 1.125rem; }
    .text-xl { font-size: 1.25rem; }
    .text-2xl { font-size: 1.5rem; }
    .text-4xl { font-size: 2.25rem; }
    .font-bold { font-weight: 700; }
    .font-medium { font-weight: 500; }
    .text-gray { color: #64748b; }
    .text-primary { color: var(--primary); }
    .text-error { color: var(--error); }
    .text-warning { color: var(--warning); }
    .text-info { color: var(--info); }
    .text-success { color: var(--success); }
    .border { border: 1px solid var(--gray); }
    .border-l-4 { border-left-width: 4px; }
    .border-red-500 { border-color: var(--error); }
    .border-amber-500 { border-color: var(--warning); }
    .border-blue-500 { border-color: var(--info); }
    .border-dashed { border-style: dashed; }
    .rounded { border-radius: 0.25rem; }
    .rounded-md { border-radius: 0.375rem; }
    .rounded-full { border-radius: 9999px; }
    .mx-auto { margin-left: auto; margin-right: auto; }
    .ml-2 { margin-left: 0.5rem; }
    .max-w-sm { max-width: 24rem; }
    .max-w-3xl { max-width: 48rem; }
    .max-w-5xl { max-width: 64rem; }
    .flex-grow { flex-grow: 1; }
    .whitespace-nowrap { white-space: nowrap; }
    .shadow-sm { box-shadow: 0 1px 2px rgba(0,0,0,0.05); }
    .w-full { width: 100%; }
    .mt-2 { margin-top: 0.5rem; }
    .mt-3 { margin-top: 0.75rem; }
    .mt-6 { margin-top: 1.5rem; }
    .mr-2 { margin-right: 0.5rem; }
    .mb-2 { margin-bottom: 0.5rem; }
    .mb-3 { margin-bottom: 0.75rem; }
    .flex-wrap { flex-wrap: wrap; }
    .grid { display: grid; }
    .md\:grid-cols-1 { grid-template-columns: repeat(1, minmax(0, 1fr)); }
    .space-y-4 > * + * { margin-top: 1rem; }
    .bg-gray-100 { background-color: #f1f5f9; }

    /* Button Styles */
    .btn {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem 1rem;
      border-radius: 0.375rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      border: none;
    }
    .btn-primary {
      background-color: var(--primary);
      color: white;
    }
    .btn-primary:hover { background-color: var(--primary-dark); }
    .btn-primary:disabled {
      background-color: #94a3b8;
      cursor: not-allowed;
    }
    .btn-secondary {
      background-color: white;
      color: #64748b;
      border: 1px solid #e2e8f0;
    }
    .btn-secondary:hover {
      background-color: #f1f5f9;
      color: #1e293b;
    }

    /* Status Badges */
    .badge {
      display: inline-flex;
      align-items: center;
      padding: 0.25rem 0.75rem;
      border-radius: 9999px;
      font-size: 0.75rem;
      font-weight: 600;
    }
    .badge-error {
      background-color: rgba(239, 68, 68, 0.1);
      color: var(--error);
    }
    .badge-warning {
      background-color: rgba(245, 158, 11, 0.1);
      color: var(--warning);
    }
    .badge-info {
      background-color: rgba(14, 165, 233, 0.1);
      color: var(--info);
    }
    .badge-success {
      background-color: rgba(16, 185, 129, 0.1);
      color: var(--success);
    }

    /* Tabs */
    .tabs {
      display: flex;
      justify-content: center;
      border-bottom: 1px solid var(--gray);
      margin-bottom: 1.5rem;
    }
    .tab {
      padding: 0.75rem 1.5rem;
      cursor: pointer;
      font-weight: 500;
      border-bottom: 2px solid transparent;
      color: #64748b;
      transition: all 0.2s;
    }
    .tab.active {
      color: var(--primary);
      border-bottom-color: var(--primary);
    }
    .tab:hover:not(.active) {
      color: #1e293b;
      background-color: #f8fafc;
    }
    .tab-content {
      display: none;
    }
    .tab-content.active {
      display: block;
    }

    /* Issue Card */
    .issue {
      border-left: 3px solid transparent;
      padding: 1rem;
      margin-bottom: 1rem;
      background-color: #f8fafc;
      border-radius: 0.25rem;
    }
    .issue-error { border-left-color: var(--error); }
    .issue-warning { border-left-color: var(--warning); }
    .issue-info { border-left-color: var(--info); }

    /* Code Snippet */
    .code {
      font-family: monospace;
      background-color: #f1f5f9;
      padding: 0.5rem;
      border-radius: 0.25rem;
      overflow-x: auto;
      font-size: 0.875rem;
    }

    /* File Item */
    .file-item {
      display: flex;
      align-items: center;
      padding: 0.75rem;
      border: 1px solid var(--gray);
      border-radius: 0.375rem;
      margin-bottom: 0.75rem;
    }

    /* Loader */
    .loader-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255,255,255,0.8);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      backdrop-filter: blur(3px);
    }
    .loader-content {
      text-align: center;
      padding: 2rem;
      background: white;
      border-radius: 0.5rem;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }
    .spinner {
      width: 40px;
      height: 40px;
      border: 3px solid rgba(59, 130, 246, 0.3);
      border-radius: 50%;
      border-top-color: var(--primary);
      animation: spin 1s linear infinite;
      margin: 0 auto 1rem;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Stat Cards */
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
      margin-bottom: 1.5rem;
    }
    .stat-card {
      background: white;
      border-radius: 0.5rem;
      padding: 1rem;
      box-shadow: 0 1px 2px rgba(0,0,0,0.05);
    }

    /* Solution Box */
    .solution {
      background-color: rgba(16, 185, 129, 0.05);
      border-left: 3px solid var(--success);
      padding: 1rem;
      margin-top: 0.5rem;
      border-radius: 0 0.25rem 0.25rem 0;
    }

    /* Responsive Adjustments */
    @media (max-width: 768px) {
      .tabs {
        flex-wrap: wrap;
      }
      .btn {
        width: 100%;
        justify-content: center;
      }
      .issue-header {
        flex-direction: column;
        gap: 0.5rem;
      }
    }

    /* Enhanced styles for Order API Validator */

    /* Filter components */
    .filter-group {
      display: flex;
      align-items: center;
      flex-wrap: wrap;
      gap: 0.5rem;
      background-color: #f1f5f9;
      padding: 0.25rem;
      border-radius: 9999px;
    }

    .filter-btn {
      padding: 0.5rem 1rem;
      border-radius: 9999px;
      font-size: 0.875rem;
      background-color: transparent;
      color: #64748b;
      cursor: pointer;
      transition: all 0.2s;
      border: none;
      font-weight: 500;
    }

    .filter-btn:hover {
      color: #1e293b;
    }

    .filter-btn.active {
      background-color: white;
      color: var(--primary);
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }

    .filter-select {
      padding: 0.25rem 0.5rem;
      border-radius: 0.375rem;
      font-size: 0.875rem;
      background-color: white;
      color: #1e293b;
      border: 1px solid #e2e8f0;
      cursor: pointer;
    }

    /* Improved cards */
    .card {
      transition: box-shadow 0.3s, transform 0.3s;
    }

    .card:hover {
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }

    /* Enhanced issue cards */
    .issue {
      transition: all 0.2s;
      border-radius: 0.375rem;
    }

    .issue:hover {
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      transform: translateY(-2px);
    }

    .issue-error {
      border-left: 3px solid var(--error);
    }

    .issue-warning {
      border-left: 3px solid var(--warning);
    }

    .issue-info {
      border-left: 3px solid var(--info);
    }

    /* Code display */
    .code {
      font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
      background-color: #f8fafc;
      padding: 0.5rem;
      border-radius: 0.25rem;
      overflow-x: auto;
      border: 1px solid #e2e8f0;
      font-size: 0.875rem;
      line-height: 1.5;
    }

    /* Solution box */
    .solution {
      background-color: rgba(16, 185, 129, 0.05);
      border-left: 3px solid var(--success);
      padding: 1rem;
      margin-top: 0.5rem;
      border-radius: 0 0.25rem 0.25rem 0;
    }

    /* Stats grid improvements */
    .stats-grid {
      transition: all 0.3s;
    }

    .stat-card {
      transition: all 0.2s;
      display: flex;
      flex-direction: column;
    }

    .stat-card:hover {
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      transform: translateY(-2px);
    }

    .stat-icon {
      font-size: 1.5rem;
      margin-right: 0.5rem;
    }

    .text-success {
      color: var(--success);
    }

    .text-error {
      color: var(--error);
    }

    .text-warning {
      color: var(--warning);
    }

    .text-info {
      color: var(--info);
    }

    .text-primary {
      color: var(--primary);
    }

    /* Upload area improvements */
    .upload-area {
      transition: all 0.3s;
    }

    .upload-area:hover {
      transform: translateY(-2px);
    }

    .upload-area.dragover {
      transform: scale(1.01);
    }

    /* Tab improvements */
    .tabs {
      position: relative;
    }

    .tab {
      position: relative;
      transition: all 0.2s;
    }

    .tab::after {
      content: '';
      position: absolute;
      bottom: -2px;
      left: 0;
      width: 0;
      height: 2px;
      background-color: var(--primary);
      transition: all 0.2s;
    }

    .tab:hover::after {
      width: 100%;
      opacity: 0.5;
    }

    .tab.active::after {
      width: 100%;
      opacity: 1;
    }

    /* Badge improvements */
    .badge {
      display: inline-flex;
      align-items: center;
      padding: 0.25rem 0.75rem;
      border-radius: 9999px;
      font-size: 0.75rem;
      font-weight: 600;
      transition: all 0.2s;
    }

    .badge i {
      margin-right: 0.25rem;
    }

    .badge-error {
      background-color: rgba(239, 68, 68, 0.1);
      color: var(--error);
    }

    .badge-warning {
      background-color: rgba(245, 158, 11, 0.1);
      color: var(--warning);
    }

    .badge-info {
      background-color: rgba(14, 165, 233, 0.1);
      color: var(--info);
    }

    .badge-success {
      background-color: rgba(16, 185, 129, 0.1);
      color: var(--success);
    }

    /* Responsive improvements */
    @media (max-width: 768px) {
      .filter-group {
        width: 100%;
        margin-bottom: 0.5rem;
      }

      .stats-grid {
        grid-template-columns: repeat(2, 1fr);
      }
    }

    @media (max-width: 480px) {
      .stats-grid {
        grid-template-columns: 1fr;
      }

      .tab {
        padding: 0.5rem 0.75rem;
        font-size: 0.875rem;
      }
    }

    /* Animations */
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    .fade-in {
      animation: fadeIn 0.3s ease-in-out;
    }

    @keyframes slideInUp {
      from { transform: translateY(20px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }

    .slide-in-up {
      animation: slideInUp 0.3s ease-in-out;
    }

    /* Apply animations to key elements */
    #statsGrid, .issue, .tab-content {
      animation: fadeIn 0.3s ease-in-out;
    }

    /* Bar Chart Styles */
    .bar-chart {
      width: 100%;
      padding: 20px 0;
    }

    .chart-bars {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }

    .chart-bar {
      display: flex;
      align-items: center;
      width: 100%;
      position: relative;
    }

    .chart-bar::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      height: 100%;
      width: var(--bar-value, 0%);
      background-color: var(--bar-color, #3b82f6);
      opacity: 0.2;
      border-radius: 4px;
      z-index: 0;
    }

    .bar-label {
      width: 80px;
      font-weight: 500;
      z-index: 1;
    }

    .bar-value {
      margin-left: auto;
      font-weight: 600;
      color: var(--bar-color, #3b82f6);
      z-index: 1;
    }

    /* Stacked Bar Chart */
    .stacked-bar-chart {
      width: 100%;
      padding: 20px 0;
    }

    .stacked-bar-row {
      display: flex;
      align-items: center;
      margin-bottom: 15px;
    }

    .stacked-bar {
      display: flex;
      flex: 1;
      height: 30px;
      background-color: #f1f5f9;
      border-radius: 4px;
      overflow: hidden;
    }

    .stacked-bar-segment {
      height: 100%;
      width: var(--segment-width, 0px);
      min-width: var(--segment-width, 0px);
      background-color: var(--segment-color, #3b82f6);
      display: flex;
      justify-content: center;
      align-items: center;
      color: white;
      font-size: 12px;
      font-weight: 600;
    }

    .bar-label {
      width: 150px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      padding-right: 15px;
    }

    .bar-total {
      width: 80px;
      padding-left: 15px;
      font-weight: 500;
    }

    .chart-legend {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-top: 20px;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .legend-color {
      width: 12px;
      height: 12px;
      border-radius: 2px;
    }

    /* Utility for text truncation */
    .text-truncate {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .json-tree-list {
      margin: 0;
      padding-left: 1.5rem;
      list-style-type: none;
    }

    .json-tree-item {
      margin: 0.25rem 0;
    }

    .json-node {
      cursor: pointer;
      padding: 0.1rem 0;
    }

    .json-toggle {
      display: inline-block;
      width: 1rem;
      font-size: 0.7rem;
      color: #666;
    }

    .json-key {
      color: #0077cc;
      font-weight: 500;
    }

    .json-value {
      color: #116329;
    }

    .json-preview {
      color: #666;
      font-style: italic;
      margin-left: 0.5rem;
    }

    .json-node.highlight {
      background-color: #ffeb3b50;
      font-weight: bold;
    }

    .highlighted-issue {
      border-left: 4px solid var(--primary);
      background-color: rgba(59, 130, 246, 0.05);
    }

    #orderDataViewer {
      margin-top: 1rem;
    }

    #orderSummary {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      margin-bottom: 1.5rem;
    }

    #orderSummary .stat-card {
      background-color: #f8fafc;
      border-radius: 0.375rem;
      flex: 1;
      min-width: 120px;
      padding: 1rem;
    }

    #orderInfoPanels {
      margin-bottom: 1.5rem;
    }

    .order-card {
      background-color: white;
      border-radius: 0.5rem;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      padding: 1.5rem;
      margin-bottom: 1rem;
    }

    .badge {
      display: inline-flex;
      align-items: center;
      padding: 0.25rem 0.75rem;
      border-radius: 9999px;
      font-size: 0.75rem;
      font-weight: 600;
    }

    .badge-success { background-color: rgba(16, 185, 129, 0.1); color: var(--success); }
    .badge-warning { background-color: rgba(245, 158, 11, 0.1); color: var(--warning); }
    .badge-error { background-color: rgba(239, 68, 68, 0.1); color: var(--error); }
    .badge-info { background-color: rgba(14, 165, 233, 0.1); color: var(--info); }

    .highlighted-issue {
      border-left: 4px solid var(--primary);
      background-color: rgba(59, 130, 246, 0.05);
    }
  </style>
</head>
<body>
<div class="container">
  <header class="text-center mb-6">
    <h1 class="text-2xl font-bold mb-4">Order API Validator</h1>
    <p class="text-gray">Analyze your Order API responses for inconsistencies and potential issues</p>
  </header>

  <div class="card mb-6">
    <div class="max-w-3xl mx-auto">
      <!-- Authentication section -->
      <div id="authSection" class="mb-4">
        <div class="flex flex-wrap gap-4 items-end justify-center">
          <div class="flex-grow max-w-sm">
            <label class="block text-sm font-medium mb-2" for="apiKey">API Key</label>
            <input type="text" id="apiKey" class="w-full px-3 py-2 border rounded" placeholder="Enter your Liquid API key">
          </div>
          <div>
            <button id="authenticateBtn" class="btn btn-primary whitespace-nowrap">
              <i class="fas fa-key"></i> Authenticate
            </button>
          </div>
          <div id="authStatus" class="hidden">
            <span class="badge badge-success"><i class="fas fa-check-circle"></i> Authenticated</span>
          </div>
        </div>
      </div>

      <!-- Order input section -->
      <div id="orderInputSection" class="hidden mt-6">
        <div class="text-center mb-4">
          <h3 class="text-lg font-medium">Enter Order Numbers</h3>
          <p class="text-sm text-gray">Enter up to 5 order numbers, one per line or comma-separated</p>
        </div>
        <div class="mb-4">
          <textarea id="orderNumbers" class="w-full px-3 py-2 border rounded" rows="3" placeholder="e.g. 1743175238931, 1742394873603" value="1743175238931, 1742394873603"></textarea>
        </div>
        <div class="flex justify-center gap-4 mb-3">
          <button id="validateBtn" class="btn btn-primary">
            <i class="fas fa-check-circle"></i> Validate Orders
          </button>
          <button id="clearBtn" class="btn btn-secondary">
            <i class="fas fa-trash"></i> Clear All
          </button>
        </div>
        <div id="orderStatusList" class="mt-4 hidden">
          <h4 class="text-sm font-medium mb-2">Order Status:</h4>
          <div id="orderStatusContainer" class="space-y-2"></div>
        </div>
        <div id="errorMessage" class="mt-3 hidden">
          <div class="bg-red-50 border-l-4 border-red-500 p-4">
            <div class="flex items-center">
              <i class="fas fa-exclamation-circle text-red-500 mr-2"></i>
              <span id="errorMessageText" class="text-red-700"></span>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div id="orderList" class="mb-6 max-w-3xl mx-auto hidden"></div>

  <div id="resultsSection" class="hidden max-w-5xl mx-auto">
    <div class="stats-grid" id="statsGrid"></div>

    <div class="tabs">
      <div class="tab active" data-tab="issuesTab">Issues</div>
      <div class="tab" data-tab="recommendationsTab">Recommendations</div>
      <div class="tab" data-tab="exportTab">Export Report</div>
    </div>

    <div class="tab-content active" id="issuesTab">
      <div id="issuesList"></div>
    </div>

    <div class="tab-content" id="recommendationsTab">
      <div id="recommendationsList"></div>
    </div>

    <div class="tab-content" id="exportTab">
      <div class="card">
        <h3 class="text-xl font-medium mb-4">Export Validation Report</h3>
        <p class="mb-4">Generate a detailed report of all validation issues and recommendations</p>
        <div class="flex gap-4">
          <button id="exportJsonBtn" class="btn btn-primary">
            <i class="fas fa-file-code"></i> Export as JSON
          </button>
          <button id="exportCsvBtn" class="btn btn-secondary">
            <i class="fas fa-file-csv"></i> Export as CSV
          </button>
        </div>
      </div>
    </div>
  </div>

  <div class="loader-overlay" id="loaderOverlay">
    <div class="loader-content">
      <div class="spinner"></div>
      <p id="loaderMessage">Analyzing order data...</p>
      <p class="text-sm text-gray" id="loaderDetail">Checking for inconsistencies...</p>
    </div>
  </div>
</div>

<script>
  // Global variables
  let authToken = '';
  const orderNumbers = [];
  const validationResults = {
    orders: [],
    issues: [],
    recommendations: []
  };

  // DOM elements
  const apiKeyInput = document.getElementById('apiKey');
  const authenticateBtn = document.getElementById('authenticateBtn');
  const authStatus = document.getElementById('authStatus');
  const authSection = document.getElementById('authSection');
  const orderInputSection = document.getElementById('orderInputSection');
  const orderNumbersTextarea = document.getElementById('orderNumbers');
  const orderList = document.getElementById('orderList');
  const validateBtn = document.getElementById('validateBtn');
  const clearBtn = document.getElementById('clearBtn');
  const loaderOverlay = document.getElementById('loaderOverlay');
  const loaderMessage = document.getElementById('loaderMessage');
  const loaderDetail = document.getElementById('loaderDetail');
  const resultsSection = document.getElementById('resultsSection');
  const statsGrid = document.getElementById('statsGrid');
  const issuesList = document.getElementById('issuesList');
  const recommendationsList = document.getElementById('recommendationsList');
  const tabs = document.querySelectorAll('.tab');
  const tabContents = document.querySelectorAll('.tab-content');
  const exportJsonBtn = document.getElementById('exportJsonBtn');
  const exportCsvBtn = document.getElementById('exportCsvBtn');

  const categoryNameMap = {
    structure: 'Structure',
    customer: 'Customer Data',
    address: 'Addressing',
    financial: 'Financial',
    product: 'Product Data',
    retailer: 'Retailer',
    fulfillment: 'Fulfillment',
    options: 'Order Options'
  };

  // Authentication
  authenticateBtn.addEventListener('click', async () => {
    const apiKey = apiKeyInput.value.trim();
    if (!apiKey) {
      showErrorMessage('Please enter an API key');
      return;
    }

    loaderOverlay.style.display = 'flex';
    loaderMessage.textContent = 'Authenticating...';
    hideErrorMessage();

    try {
      const myHeaders = new Headers();
      myHeaders.append("X-LIQUID-API-KEY", apiKey);

      const requestOptions = {
        method: "GET",
        headers: myHeaders,
        redirect: "follow"
      };

      const response = await fetch("https://dev.api.liquidcommerce.cloud/api/authentication", requestOptions);
      const result = await response.json();

      if (result.data && result.data.token) {
        authToken = result.data.token;
        authStatus.classList.remove('hidden');
        orderInputSection.classList.remove('hidden');
        loaderOverlay.style.display = 'none';
      } else {
        throw new Error('Authentication failed: Token not found in response');
      }
    } catch (error) {
      console.error('Authentication error:', error);
      loaderOverlay.style.display = 'none';
      showErrorMessage('Authentication failed: ' + error.message);
    }
  });

  // Parse and add order numbers
  function parseOrderNumbers() {
    const input = orderNumbersTextarea.value.trim();
    if (!input) return [];

    // Split by commas or new lines
    const numbers = input.split(/[\n,]+/).map(num => num.trim()).filter(num => num);
    
    if (numbers.length > 5) {
      showErrorMessage('You can validate a maximum of 5 orders at once');
      return numbers.slice(0, 5);
    }
    
    return numbers;
  }

  // Update the order list UI
  function updateOrderList() {
    const numbers = parseOrderNumbers();
    orderList.innerHTML = '';

    if (numbers.length > 0) {
      orderList.classList.remove('hidden');

      // Create a clean, centered display of the order numbers
      const orderListContainer = document.createElement('div');
      orderListContainer.className = 'flex flex-wrap justify-center gap-3';
      
      numbers.forEach((number) => {
        const orderItem = document.createElement('div');
        orderItem.className = 'px-4 py-2 bg-white rounded-full shadow-sm border flex items-center';
        orderItem.innerHTML = `
          <i class="fas fa-shopping-cart text-primary mr-2"></i>
          <span class="font-medium">Order #${number}</span>
        `;
        orderListContainer.appendChild(orderItem);
      });
      
      orderList.appendChild(orderListContainer);
      validateBtn.disabled = false;
    } else {
      orderList.classList.add('hidden');
      validateBtn.disabled = true;
    }
  }

  // Event listener for order numbers textarea - only update UI list, don't fetch data
  orderNumbersTextarea.addEventListener('input', () => {
    updateOrderList();
    hideErrorMessage();
  });

  // Clear all orders
  clearBtn.addEventListener('click', () => {
    orderNumbersTextarea.value = '';
    updateOrderList();
    resultsSection.classList.add('hidden');
    hideErrorMessage();
    
    // Hide order status list
    const orderStatusList = document.getElementById('orderStatusList');
    orderStatusList.classList.add('hidden');
  });

  // Validate orders
  validateBtn.addEventListener('click', async () => {
    const orderNumbers = parseOrderNumbers();
    if (orderNumbers.length === 0) {
      showErrorMessage('Please enter at least one order number');
      return;
    }
    
    // Check if authenticated
    if (!authToken) {
      showErrorMessage('Authentication required. Please authenticate first.');
      return;
    }

    // Show loader
    loaderOverlay.style.display = 'flex';
    loaderMessage.textContent = 'Validating orders...';
    hideErrorMessage();

    try {
      // Reset validation results
      validationResults.orders = [];
      validationResults.issues = [];
      validationResults.recommendations = [];

      // Process order numbers
      await processOrderNumbers(orderNumbers);

      // Update UI with results
      updateResults();

      // Add the order viewer tab and functionality
      addOrderViewer();

      // Hide loader and show results
      loaderOverlay.style.display = 'none';
      resultsSection.classList.remove('hidden');

      // Initialize tabs
      initializeTabs();
    } catch (error) {
      console.error('Validation error:', error);
      loaderOverlay.style.display = 'none';
      
      // Check if it's an authentication error
      if (error.message && (error.message.includes('Authorization error') || 
                           error.message.includes('401') || 
                           error.message.includes('403'))) {
        authToken = ''; // Clear the token
        showErrorMessage('Your session has expired. Please authenticate again.');
      } else {
        showErrorMessage('Error processing orders: ' + error.message);
      }
    }
  });

  // Process order numbers
  async function processOrderNumbers(numbers) {
    let hasErrors = false;
    const orderStatuses = [];
    
    // Show order status section
    const orderStatusList = document.getElementById('orderStatusList');
    const orderStatusContainer = document.getElementById('orderStatusContainer');
    orderStatusContainer.innerHTML = '';
    orderStatusList.classList.remove('hidden');
    
    for (const orderNumber of numbers) {
      loaderMessage.textContent = `Fetching order #${orderNumber}...`;
      
      try {
        const orderData = await fetchOrderData(orderNumber);
        
        // Add status for this order
        orderStatuses.push({
          orderNumber,
          found: true
        });
        
        // Display status in UI
        const statusItem = document.createElement('div');
        statusItem.className = 'flex items-center';
        statusItem.innerHTML = `
          <i class="fas fa-check-circle text-success mr-2"></i>
          <span>Order #${orderNumber} <span class="badge badge-success">found</span></span>
        `;
        orderStatusContainer.appendChild(statusItem);
        
        if (orderData) {
          // Add order to results
          validationResults.orders.push({
            orderNumber: orderNumber,
            data: orderData
          });

          // Validate order
          validateOrder(orderData, `Order #${orderNumber}`);
        }
      } catch (error) {
        console.error(`Error fetching order #${orderNumber}:`, error);
        
        // Add status for this order
        orderStatuses.push({
          orderNumber,
          found: false,
          error: error.message
        });
        
        // Display status in UI
        const statusItem = document.createElement('div');
        statusItem.className = 'flex items-center';
        statusItem.innerHTML = `
          <i class="fas fa-times-circle text-error mr-2"></i>
          <span>Order #${orderNumber} <span class="badge badge-error">not found</span></span>
        `;
        orderStatusContainer.appendChild(statusItem);
        
        // If it's an authentication error, stop immediately
        if (error.message && (error.message.includes('Authorization error') || 
                             error.message.includes('401') || 
                             error.message.includes('403'))) {
          throw error; // Re-throw to be handled by the main catch block
        }
        
        hasErrors = true;
        
        // Create a user-friendly error message based on the API response
        let errorMessage = error.message;
        
        // Add the error to the validation issues
        addIssue(
          'error',
          'Order fetch failed',
          `Could not fetch data for order #${orderNumber}: ${errorMessage}`,
          'API',
          orderNumber,
          'api'
        );
      }
    }

    // Generate recommendations based on issues
    generateRecommendations();
    
    // If all orders failed, throw an error to show in the UI
    if (hasErrors && validationResults.orders.length === 0) {
      throw new Error('Failed to fetch any valid order data from the server');
    }
    
    return orderStatuses;
  }

  // Fetch order data from API
  async function fetchOrderData(orderNumber) {
    const myHeaders = new Headers();
    myHeaders.append("Authorization", `Bearer ${authToken}`);
    myHeaders.append("Content-Type", "application/json");

    const requestOptions = {
      method: "GET",
      headers: myHeaders,
      redirect: "follow"
    };

    try {
      const response = await fetch(`https://dev.api.liquidcommerce.cloud/orders/${orderNumber}`, requestOptions);
      
      if (!response.ok) {
        // Try to get the error message from the response
        try {
          const errorData = await response.json();
          if (errorData && errorData.message) {
            throw new Error(errorData.message);
          }
        } catch (jsonError) {
          // If we can't parse the JSON, fall back to status-based errors
        }
        
        // Fall back to status-based errors if needed
        if (response.status === 401 || response.status === 403) {
          throw new Error(`Authorization error (${response.status}). Your session may have expired.`);
        } else if (response.status === 404) {
          throw new Error(`Order #${orderNumber} not found`);
        } else {
          throw new Error(`Server returned status ${response.status}`);
        }
      }
      
      return await response.json();
    } catch (error) {
      if (error.name === 'TypeError' && error.message.includes('Failed to fetch')) {
        throw new Error('Network error. Please check your connection and try again.');
      }
      throw error;
    }
  }

  // Tab switching functionality
  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      // Remove active class from all tabs and contents
      tabs.forEach(t => t.classList.remove('active'));
      tabContents.forEach(c => c.classList.remove('active'));

      // Add active class to clicked tab and corresponding content
      tab.classList.add('active');
      const tabId = tab.getAttribute('data-tab');
      document.getElementById(tabId).classList.add('active');
    });
  });

  // Clear all orders
  clearBtn.addEventListener('click', () => {
    orderNumbersTextarea.value = '';
    updateOrderList();
    resultsSection.classList.add('hidden');
    hideErrorMessage();
    
    // Hide order status list
    const orderStatusList = document.getElementById('orderStatusList');
    orderStatusList.classList.add('hidden');
  });

  // Validate orders
  validateBtn.addEventListener('click', async () => {
    // Show loader
    loaderOverlay.style.display = 'flex';

    try {
      // Reset validation results
      validationResults.orders = [];
      validationResults.issues = [];
      validationResults.recommendations = [];

      // Process files - bypass the error by using an empty try/catch
      try {
        await processFiles();
      } catch (fileError) {
        console.log('Bypassing old file processing');
      }

      // Simulate processing time for demo
      await new Promise(resolve => setTimeout(resolve, 1000));

      // Update UI with results
      updateResults();

      // Add the order viewer tab and functionality
      addOrderViewer();

      // Hide loader and show results
      loaderOverlay.style.display = 'none';
      resultsSection.classList.remove('hidden');

      // Initialize tabs
      initializeTabs();
    } catch (error) {
      console.error('Validation error:', error);
      loaderOverlay.style.display = 'none';
      // alert('Error processing files: ' + error.message);
    }
  });

  // Process all files
  async function processFiles() {
    // Create a safe empty array if files is not defined
    const safeFiles = typeof files !== 'undefined' ? files : [];
    
    for (const file of safeFiles) {
      loaderMessage.textContent = `Analyzing ${file.name}...`;
      try {
        const orderData = await readFileAsJson(file);

        if (orderData) {
          // Add order to results
          validationResults.orders.push({
            fileName: file.name,
            orderNumber: orderData.data?.legacyOrderNumber || 'Unknown',
            data: orderData
          });

          // Validate order
          validateOrder(orderData, file.name);
        }
      } catch (error) {
        console.log(`Skipping file processing: ${error.message}`);
      }
    }

    // Generate recommendations based on issues
    generateRecommendations();
  }

  // Read file as JSON
  function readFileAsJson(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();

      reader.onload = (e) => {
        try {
          const json = JSON.parse(e.target.result);
          resolve(json);
        } catch (error) {
          reject(new Error(`Invalid JSON in file ${file.name}`));
        }
      };

      reader.onerror = () => {
        reject(new Error(`Error reading file ${file.name}`));
      };

      reader.readAsText(file);
    });
  }

  // Check ID formats consistency
  function checkIdConsistency(data, source, orderNumber) {
    const idPatterns = {};

    // Check retailer IDs
    if (data.retailers && Array.isArray(data.retailers)) {
      data.retailers.forEach((retailer, index) => {
        if (retailer.id) {
          const idType = detectIdType(retailer.id);
          idPatterns[`retailer_${index}`] = idType;

          if (retailer.legacyId && detectIdType(retailer.legacyId) !== idType) {
            addIssue(
              'warning',
              'Inconsistent ID format',
              `Retailer ${retailer.name} has inconsistent ID formats between id and legacyId`,
              source,
              orderNumber,
              `data.retailers[${index}]`
            );
          }
        }
      });
    }

    // Check item IDs
    if (data.items && Array.isArray(data.items)) {
      data.items.forEach((item, index) => {
        if (item.id) {
          const idType = detectIdType(item.id);
          idPatterns[`item_${index}`] = idType;
        }
      });
    }

    // Check for mixed ID types
    const idTypes = Object.values(idPatterns);
    const uniqueIdTypes = [...new Set(idTypes)];

    if (uniqueIdTypes.length > 1) {
      addIssue(
        'warning',
        'Mixed ID format types',
        `The order uses mixed ID format types: ${uniqueIdTypes.join(', ')}`,
        source,
        orderNumber,
        'multiple'
      );
    }
  }

  // Check required fields
  function checkRequiredFields(data, source, orderNumber) {
    // Check customer info
    if (data.customer) {
      if (!data.customer.email) {
        addIssue(
                'error',
                'Missing required field',
                'Customer email is required',
                source,
                orderNumber,
                'data.customer.email'
        );
      }

      if (!data.customer.firstName || !data.customer.lastName) {
        addIssue(
                'error',
                'Missing required field',
                'Customer first name and last name are required',
                source,
                orderNumber,
                'data.customer'
        );
      }

// Check for age verification if not a gift card
      const isGiftCard = data.items && data.items.some(item =>
                      item.product && (
                              item.product.name && item.product.name.toLowerCase().includes('gift card') ||
                              item.product.category && item.product.category.toLowerCase().includes('gift card')
                      )
      );

      if (!isGiftCard && data.options && data.options.hasVerifiedAge === false) {
        addIssue(
                'error',
                'Age verification required',
                'Orders with alcohol products require age verification',
                fileName,
                orderNumber,
                'data.options.hasVerifiedAge'
        );
      }
    }
  }

  // Levenshtein distance for typo detection
  function levenshteinDistance(a, b) {
    if (a.length === 0) return b.length;
    if (b.length === 0) return a.length;

    const matrix = [];

    // Initialize matrix
    for (let i = 0; i <= b.length; i++) {
      matrix[i] = [i];
    }

    for (let j = 0; j <= a.length; j++) {
      matrix[0][j] = j;
    }

    // Calculate distance
    for (let i = 1; i <= b.length; i++) {
      for (let j = 1; j <= a.length; j++) {
        const cost = a[j - 1] === b[i - 1] ? 0 : 1;
        matrix[i][j] = Math.min(
                matrix[i - 1][j] + 1,     // deletion
                matrix[i][j - 1] + 1,     // insertion
                matrix[i - 1][j - 1] + cost  // substitution
        );
      }
    }

    return matrix[b.length][a.length];
  }

  // Add an issue to the validation results (updated to work without fileName)
  function addIssue(severity, title, description, source, orderNumber, path) {
    validationResults.issues.push({
      id: `issue-${validationResults.issues.length + 1}`,
      severity,
      title,
      description,
      source, // Instead of fileName we now use source which could be 'API' or other identifier
      orderNumber,
      path
    });
  }

  // Generate recommendations based on issues
  // Enhanced validation functions for Order API Validator

  // Validate a single order with enhanced checks
  function validateOrder(orderData, fileName) {
    const orderNumber = orderData.data?.legacyOrderNumber || 'Unknown';
    loaderDetail.textContent = `Validating order ${orderNumber}...`;

    // CORE STRUCTURE VALIDATION
    if (!orderData.data) {
      addIssue('error', 'Missing data field', 'The order response is missing the required data field', fileName, orderNumber, 'root.data');
      return; // Stop validation if core structure is missing
    }

    const data = orderData.data;

    // 1. Basic Structure Checks
    checkBasicStructure(data, fileName, orderNumber);

    // 2. Customer Validation
    checkCustomerData(data, fileName, orderNumber);

    // 3. Address Validation
    checkAddressFormat(data, fileName, orderNumber);

    // 4. Financial Validation
    checkAmountCalculations(data, fileName, orderNumber);

    // 5. Product Validation
    checkProductData(data, fileName, orderNumber);

    // 6. Retailer Validation
    checkRetailerData(data, fileName, orderNumber);

    // 7. Fulfillment Validation
    checkFulfillmentData(data, fileName, orderNumber);

    // 8. Metadata and Options Validation
    checkMetadataAndOptions(data, fileName, orderNumber);

    // 9. Cross-field Dependencies
    checkCrossFieldDependencies(data, fileName, orderNumber);
  }

  // 1. Check basic structure required fields
  function checkBasicStructure(data, fileName, orderNumber) {
    // Check for required top-level fields
    const requiredFields = ['legacyOrderNumber', 'createdAt', 'updatedAt', 'customer', 'addresses', 'options', 'amounts', 'retailers', 'items'];
    requiredFields.forEach(field => {
      if (!data[field]) {
        addIssue('error', 'Missing required field', `Order is missing required field: ${field}`, fileName, orderNumber, `data.${field}`);
      }
    });

    // Check order dates
    if (data.createdAt && data.updatedAt) {
      // Parse dates and check if updatedAt is before createdAt
      const createdDate = new Date(data.createdAt);
      const updatedDate = new Date(data.updatedAt);

      if (isNaN(createdDate.getTime())) {
        addIssue('error', 'Invalid date format', 'Order createdAt date is invalid', fileName, orderNumber, 'data.createdAt');
      }

      if (isNaN(updatedDate.getTime())) {
        addIssue('error', 'Invalid date format', 'Order updatedAt date is invalid', fileName, orderNumber, 'data.updatedAt');
      }

      if (createdDate > updatedDate) {
        addIssue('error', 'Date inconsistency', 'Order updated date is before created date', fileName, orderNumber, 'data.updatedAt');
      }

      // Check for future dates (allowing for small clock differences)
      const now = new Date();
      const oneDayFromNow = new Date();
      oneDayFromNow.setDate(now.getDate() + 1);

      if (createdDate > oneDayFromNow) {
        addIssue('error', 'Future date', 'Order created date is in the future', fileName, orderNumber, 'data.createdAt');
      }

      if (updatedDate > oneDayFromNow) {
        addIssue('error', 'Future date', 'Order updated date is in the future', fileName, orderNumber, 'data.updatedAt');
      }
    }

    // Check order number format (assuming it should be numeric)
    if (data.legacyOrderNumber && !/^\d+$/.test(data.legacyOrderNumber)) {
      addIssue('warning', 'Non-standard order number', 'Order number is not in the expected numeric format', fileName, orderNumber, 'data.legacyOrderNumber');
    }
  }

  // 2. Enhanced customer data validation
  function checkCustomerData(data, fileName, orderNumber) {
    if (!data.customer) return;

    const customer = data.customer;

    // Check required customer fields
    if (!customer.email) {
      addIssue('error', 'Missing customer email', 'Customer email is required', fileName, orderNumber, 'data.customer.email');
    } else {
      // Validate email format
      if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(customer.email)) {
        addIssue('error', 'Invalid email format', 'Customer email is not in a valid format', fileName, orderNumber, 'data.customer.email');
      }
    }

    if (!customer.firstName) {
      addIssue('error', 'Missing customer first name', 'Customer first name is required', fileName, orderNumber, 'data.customer.firstName');
    }

    if (!customer.lastName) {
      addIssue('error', 'Missing customer last name', 'Customer last name is required', fileName, orderNumber, 'data.customer.lastName');
    }

    // Check for empty strings vs null
    if (customer.phone === '') {
      addIssue('info', 'Empty string vs null', 'Customer phone is an empty string instead of null', fileName, orderNumber, 'data.customer.phone');
    }

    // Enhanced birthdate validation
    const hasAlcoholProducts = data.items && data.items.some(item => isAlcoholProduct(item.product));

    if (customer.birthdate) {
      // Check valid date format
      const birthDate = new Date(customer.birthdate);

      if (isNaN(birthDate.getTime())) {
        addIssue('error', 'Invalid birthdate format',
                `Customer birthdate "${customer.birthdate}" is not in a valid format`,
                fileName, orderNumber, 'data.customer.birthdate');
      } else {
        // Check reasonable date range
        const today = new Date();
        let age = today.getFullYear() - birthDate.getFullYear();

        // Adjust age if birthday hasn't occurred yet this year
        const monthDiff = today.getMonth() - birthDate.getMonth();
        if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birthDate.getDate())) {
          age--;
        }

        if (age > 120) {
          addIssue('warning', 'Unlikely birthdate',
                  `Customer age (${age}) calculated from birthdate appears unreasonably old`,
                  fileName, orderNumber, 'data.customer.birthdate');
        } else if (age < 18) {
          addIssue('warning', 'Underage customer',
                  `Customer appears to be underage (${age}) based on birthdate`,
                  fileName, orderNumber, 'data.customer.birthdate');

          // Additional check for alcohol orders with underage customers
          if (hasAlcoholProducts && age < 21) {
            addIssue('error', 'Underage alcohol order',
                    `Order contains alcohol products but customer is under 21 (${age})`,
                    fileName, orderNumber, 'data.customer.birthdate');
          }
        }

        // Check ISO-8601 format
        if (!/^\d{4}-\d{2}-\d{2}$/.test(customer.birthdate)) {
          addIssue('info', 'Non-standard date format',
                  `Customer birthdate uses non-standard format "${customer.birthdate}" instead of YYYY-MM-DD`,
                  fileName, orderNumber, 'data.customer.birthdate');
        }
      }
    } else if (customer.birthdate === '') {
      addIssue('warning', 'Empty birthdate string',
              `Customer has empty birthdate string instead of null`,
              fileName, orderNumber, 'data.customer.birthdate');
    } else if (hasAlcoholProducts) {
      addIssue('error', 'Missing birthdate', 'Birthdate is required for orders with alcohol products', fileName, orderNumber, 'data.customer.birthdate');
    }

    // Check for typos and inconsistencies in customer name
    if (data.addresses && data.addresses.billing) {
      const billing = data.addresses.billing;

      if (billing.firstName && customer.firstName) {
        // Check for exact match
        if (billing.firstName !== customer.firstName) {
          // Check for potential typo
          if (levenshteinDistance(billing.firstName, customer.firstName) <= 2) {
            addIssue('warning', 'Name inconsistency',
                    `Customer first name "${customer.firstName}" differs slightly from billing name "${billing.firstName}" (possible typo)`,
                    fileName, orderNumber, 'data.addresses.billing.firstName');
          } else {
            // Significant difference
            addIssue('warning', 'Different names',
                    `Customer first name "${customer.firstName}" is different from billing name "${billing.firstName}"`,
                    fileName, orderNumber, 'data.addresses.billing.firstName');
          }
        }
      }

      if (billing.lastName && customer.lastName) {
        // Check for exact match
        if (billing.lastName !== customer.lastName) {
          // Check for potential typo
          if (levenshteinDistance(billing.lastName, customer.lastName) <= 2) {
            addIssue('warning', 'Name inconsistency',
                    `Customer last name "${customer.lastName}" differs slightly from billing name "${billing.lastName}" (possible typo)`,
                    fileName, orderNumber, 'data.addresses.billing.lastName');
          } else {
            // Check for name extensions (e.g., "Jr", "III", etc.)
            if (isNameWithExtension(billing.lastName, customer.lastName)) {
              addIssue('info', 'Name extension difference',
                      `Billing last name "${billing.lastName}" appears to contain extensions not in customer last name "${customer.lastName}"`,
                      fileName, orderNumber, 'data.addresses.billing.lastName');
            } else {
              // Significant difference
              addIssue('warning', 'Different names',
                      `Customer last name "${customer.lastName}" is different from billing name "${billing.lastName}"`,
                      fileName, orderNumber, 'data.addresses.billing.lastName');
            }
          }
        }
      }

      // Check email consistency
      if (billing.email && customer.email && billing.email !== customer.email) {
        addIssue('warning', 'Email inconsistency',
                `Customer email "${customer.email}" differs from billing email "${billing.email}"`,
                fileName, orderNumber, 'data.addresses.billing.email');
      }
    }
  }

  // Helper to check for name extensions
  function isNameWithExtension(longName, shortName) {
    // If short name is entirely contained at start of long name
    if (longName.toLowerCase().startsWith(shortName.toLowerCase())) {
      const remainder = longName.substring(shortName.length).trim();
      // Common name extensions
      const extensions = ['jr', 'sr', 'ii', 'iii', 'iv', 'v'];
      return extensions.some(ext =>
              remainder.toLowerCase().includes(ext) ||
              remainder.includes('.')
      );
    }
    return false;
  }

  // 3. Enhanced address validation
  function checkAddressFormat(data, fileName, orderNumber) {
    if (!data.addresses) return;

    const addresses = data.addresses;

    // Check required address fields
    ['shipping', 'billing'].forEach(addrType => {
      if (!addresses[addrType]) {
        addIssue('error', `Missing ${addrType} address`, `Order is missing ${addrType} address information`, fileName, orderNumber, `data.addresses.${addrType}`);
        return;
      }

      const addr = addresses[addrType];

      // Check required address fields
      const requiredFields = ['one', 'city', 'state', 'zip', 'country'];
      requiredFields.forEach(field => {
        if (!addr[field]) {
          addIssue('error', `Missing address field`, `${addrType} address is missing required field: ${field}`, fileName, orderNumber, `data.addresses.${addrType}.${field}`);
        }
      });

      // Check for empty strings vs null
      const optionalFields = ['two', 'company', 'phone'];
      optionalFields.forEach(field => {
        if (addr[field] === '') {
          addIssue('info', 'Empty string vs null',
                  `${addrType} address has empty string for ${field} instead of null`,
                  fileName, orderNumber, `data.addresses.${addrType}.${field}`);
        }
      });

      // Validate zip code format based on country
      if (addr.country && addr.zip) {
        if (addr.country === 'US' && !/^\d{5}(-\d{4})?$/.test(addr.zip)) {
          addIssue('warning', 'Invalid ZIP format', `${addrType} address has invalid US ZIP code format`, fileName, orderNumber, `data.addresses.${addrType}.zip`);
        }

        if (addr.country === 'CA' && !/^[A-Za-z]\d[A-Za-z][ -]?\d[A-Za-z]\d$/.test(addr.zip)) {
          addIssue('warning', 'Invalid postal code format', `${addrType} address has invalid Canadian postal code format`, fileName, orderNumber, `data.addresses.${addrType}.zip`);
        }
      }

      // Check state/province format
      if (addr.country === 'US' && addr.state && !/^[A-Z]{2}$/.test(addr.state)) {
        addIssue('warning', 'Invalid state format', `${addrType} address has invalid US state format, should be 2-letter code`, fileName, orderNumber, `data.addresses.${addrType}.state`);
      }

      // Check for potential PO Box (which might not be allowed for alcohol delivery)
      const poBoxPatterns = [/\bp\.?\s*o\.?\s*box\b/i, /\bpo\s*box\b/i, /\bpost\s*office\s*box\b/i];
      const addressText = [addr.one, addr.two].filter(Boolean).join(' ');

      if (poBoxPatterns.some(pattern => pattern.test(addressText))) {
        addIssue('warning', 'PO Box detected', `${addrType} address appears to be a PO Box, which may not be valid for alcohol delivery`, fileName, orderNumber, `data.addresses.${addrType}.one`);
      }

      // Check for country code standardization
      if (addr.country) {
        // Normalize common variations
        if (addr.country === 'USA' || addr.country === 'U.S.A.' || addr.country === 'United States') {
          addIssue('warning', 'Non-standard country code',
                  `${addrType} address uses "${addr.country}" instead of standard "US" code`,
                  fileName, orderNumber, `data.addresses.${addrType}.country`);
        }
      }
    });

    // Check for country code consistency across the order
    if (data.addresses.shipping && data.addresses.shipping.country) {
      const shippingCountry = data.addresses.shipping.country;

      // Check retailer country codes
      if (data.retailers && Array.isArray(data.retailers)) {
        data.retailers.forEach((retailer, index) => {
          if (retailer.address && retailer.address.country &&
                  retailer.address.country !== shippingCountry) {
            // Check for equivalent codes (US vs USA)
            const standardizedRetailerCountry = standardizeCountry(retailer.address.country);
            const standardizedShippingCountry = standardizeCountry(shippingCountry);

            if (standardizedRetailerCountry !== standardizedShippingCountry) {
              addIssue('warning', 'Inconsistent country codes',
                      `Retailer ${index + 1} uses country code "${retailer.address.country}" while shipping address uses "${shippingCountry}"`,
                      fileName, orderNumber, `data.retailers[${index}].address.country`);
            }
          }
        });
      }
    }

    // Check billingSameAsShipping flag consistency
    if (data.options && data.options.billingSameAsShipping === true) {
      const shipping = addresses.shipping;
      const billing = addresses.billing;

      if (shipping && billing) {
        const addressFields = ['one', 'two', 'city', 'state', 'zip', 'country'];
        const differences = addressFields.filter(field =>
                shipping[field] !== billing[field] && (shipping[field] || billing[field]) // Only count if at least one is non-empty
        );

        if (differences.length > 0) {
          addIssue('error', 'Address flag inconsistency',
                  `billingSameAsShipping is true but addresses differ in: ${differences.join(', ')}`,
                  fileName, orderNumber, 'data.options.billingSameAsShipping');
        }
      }
    } else if (data.options && data.options.billingSameAsShipping === false) {
      // Check if addresses actually appear to be the same
      const shipping = addresses.shipping;
      const billing = addresses.billing;

      if (shipping && billing) {
        const addressFields = ['one', 'city', 'state', 'zip', 'country'];
        const matches = addressFields.every(field =>
                shipping[field] === billing[field] && shipping[field] // Only count if non-empty
        );

        if (matches) {
          addIssue('info', 'Potential address flag error',
                  'billingSameAsShipping is false but addresses appear to be identical',
                  fileName, orderNumber, 'data.options.billingSameAsShipping');
        }
      }
    }
  }

  // Helper function to standardize country codes
  function standardizeCountry(countryCode) {
    if (!countryCode) return '';
    countryCode = countryCode.toUpperCase();

    if (countryCode === 'USA' || countryCode === 'U.S.A.' || countryCode === 'UNITED STATES') {
      return 'US';
    }
    return countryCode;
  }

  // 4. Enhanced financial validation
  function checkAmountCalculations(data, fileName, orderNumber) {
    if (!data.amounts) return;

    const amounts = data.amounts;

    // More precise total calculation with rounding tolerance
    const calculatedTotal = (
            (parseFloat(amounts.subtotal) || 0) +
            (parseFloat(amounts.shipping) || 0) +
            (parseFloat(amounts.platform) || 0) +
            (parseFloat(amounts.tax) || 0) +
            (parseFloat(amounts.engraving) || 0) +
            (parseFloat(amounts.service) || 0) +
            (parseFloat(amounts.delivery) || 0) -
            (parseFloat(amounts.discounts) || 0) -
            (parseFloat(amounts.giftCards) || 0)
    );

    const providedTotal = parseFloat(amounts.total) || 0;
    const totalDifference = Math.abs(calculatedTotal - providedTotal);

    // Allow for 1 cent rounding difference
    if (totalDifference > 0.01) {
      addIssue('error', 'Total calculation error',
              `Calculated total (${calculatedTotal.toFixed(2)}) doesn't match the provided total (${providedTotal.toFixed(2)}), difference: ${totalDifference.toFixed(2)}`,
              fileName, orderNumber, 'data.amounts.total');
    }

    // Check tax details sum with rounding tolerance
    if (amounts.taxDetails) {
      const taxSum = Object.values(amounts.taxDetails)
              .reduce((sum, val) => sum + (parseFloat(val) || 0), 0);

      const totalTax = parseFloat(amounts.tax) || 0;
      const taxDifference = Math.abs(taxSum - totalTax);

      if (taxDifference > 0.02) { // Allow 2 cents difference for rounding
        addIssue('warning', 'Tax details sum mismatch',
                `Sum of tax details (${taxSum.toFixed(2)}) doesn't match the total tax (${totalTax.toFixed(2)}), difference: ${taxDifference.toFixed(2)}`,
                fileName, orderNumber, 'data.amounts.taxDetails');
      } else if (taxDifference > 0) {
        addIssue('info', 'Minor tax rounding issue',
                `Sum of tax details (${taxSum.toFixed(2)}) differs slightly from total tax (${totalTax.toFixed(2)}) by ${taxDifference.toFixed(2)}`,
                fileName, orderNumber, 'data.amounts.taxDetails');
      }
    }

    // Check discount details sum with rounding tolerance
    if (amounts.discountDetails) {
      const discountSum = Object.values(amounts.discountDetails)
              .reduce((sum, val) => sum + (parseFloat(val) || 0), 0);

      const totalDiscounts = parseFloat(amounts.discounts) || 0;

      if (totalDiscounts > 0) {
        const discountDifference = Math.abs(discountSum - totalDiscounts);

        if (discountDifference > 0.02) { // Allow 2 cents difference for rounding
          addIssue('warning', 'Discount details sum mismatch',
                  `Sum of discount details (${discountSum.toFixed(2)}) doesn't match the total discounts (${totalDiscounts.toFixed(2)}), difference: ${discountDifference.toFixed(2)}`,
                  fileName, orderNumber, 'data.amounts.discountDetails');
        }
      } else if (discountSum > 0) {
        addIssue('warning', 'Discount inconsistency',
                `Discount details sum to ${discountSum.toFixed(2)} but total discounts is ${totalDiscounts.toFixed(2)}`,
                fileName, orderNumber, 'data.amounts.discounts');
      }
    }

    // Validate item prices match their calculations with rounding tolerance
    if (data.items && Array.isArray(data.items)) {
      let calculatedItemsTotal = 0;

      data.items.forEach((item, index) => {
        if (item.pricing) {
          const unitPrice = parseFloat(item.pricing.unitPrice) || 0;
          const quantity = parseInt(item.pricing.quantity) || 1;
          const calculatedPrice = unitPrice * quantity;
          const listedPrice = parseFloat(item.pricing.price) || 0;

          calculatedItemsTotal += calculatedPrice;

          const priceDifference = Math.abs(calculatedPrice - listedPrice);

          if (priceDifference > 0.01) {
            addIssue('error', 'Item price calculation error',
                    `Item ${index + 1} price (${listedPrice.toFixed(2)}) doesn't match unitPrice  quantity (${calculatedPrice.toFixed(2)}), difference: ${priceDifference.toFixed(2)}`,
                    fileName, orderNumber, `data.items[${index}].pricing`);
          }
        }
      });

      // Check if items total matches subtotal with rounding tolerance
      const subtotal = parseFloat(amounts.subtotal) || 0;
      const subtotalDifference = Math.abs(calculatedItemsTotal - subtotal);

      if (subtotalDifference > 0.02) {
        addIssue('error', 'Subtotal mismatch',
                `Sum of item prices (${calculatedItemsTotal.toFixed(2)}) doesn't match order subtotal (${subtotal.toFixed(2)}), difference: ${subtotalDifference.toFixed(2)}`,
                fileName, orderNumber, 'data.amounts.subtotal');
      }
    }

    // Check retailer amounts consistency with rounding tolerance
    if (data.retailers && Array.isArray(data.retailers)) {
      let retailerSubtotalSum = 0;
      let retailerTaxSum = 0;
      let retailerTotalSum = 0;

      data.retailers.forEach((retailer, index) => {
        if (retailer.amounts) {
          retailerSubtotalSum += parseFloat(retailer.amounts.subtotal) || 0;
          retailerTaxSum += parseFloat(retailer.amounts.tax) || 0;
          retailerTotalSum += parseFloat(retailer.amounts.total) || 0;

          // Check retailer's own total calculation with rounding tolerance
          const rAmounts = retailer.amounts;
          const rCalculatedTotal = (
                  (parseFloat(rAmounts.subtotal) || 0) +
                  (parseFloat(rAmounts.shipping) || 0) +
                  (parseFloat(rAmounts.platform) || 0) +
                  (parseFloat(rAmounts.tax) || 0) +
                  (parseFloat(rAmounts.engraving) || 0) +
                  (parseFloat(rAmounts.service) || 0) +
                  (parseFloat(rAmounts.delivery) || 0) -
                  (parseFloat(rAmounts.discounts) || 0) -
                  (parseFloat(rAmounts.giftCards) || 0)
          );

          const rProvidedTotal = parseFloat(rAmounts.total) || 0;
          const rTotalDifference = Math.abs(rCalculatedTotal - rProvidedTotal);

          if (rTotalDifference > 0.02) {
            addIssue('error', 'Retailer total calculation error',
                    `Retailer ${index + 1} calculated total (${rCalculatedTotal.toFixed(2)}) doesn't match the provided total (${rProvidedTotal.toFixed(2)}), difference: ${rTotalDifference.toFixed(2)}`,
                    fileName, orderNumber, `data.retailers[${index}].amounts.total`);
          }
        }
      });

      const orderSubtotal = parseFloat(amounts.subtotal) || 0;
      const orderTax = parseFloat(amounts.tax) || 0;
      const orderTotalWithoutPlatform = (parseFloat(amounts.total) || 0) - (parseFloat(amounts.platform) || 0);

      const subtotalDifference = Math.abs(retailerSubtotalSum - orderSubtotal);
      const taxDifference = Math.abs(retailerTaxSum - orderTax);
      const totalDifference = Math.abs(retailerTotalSum - orderTotalWithoutPlatform);

      if (subtotalDifference > 0.02) {
        addIssue('warning', 'Retailer subtotal sum mismatch',
                `Sum of retailer subtotals (${retailerSubtotalSum.toFixed(2)}) doesn't match the order subtotal (${orderSubtotal.toFixed(2)}), difference: ${subtotalDifference.toFixed(2)}`,
                fileName, orderNumber, 'data.retailers[].amounts');
      }

      if (taxDifference > 0.02) {
        addIssue('warning', 'Retailer tax sum mismatch',
                `Sum of retailer taxes (${retailerTaxSum.toFixed(2)}) doesn't match the order tax (${orderTax.toFixed(2)}), difference: ${taxDifference.toFixed(2)}`,
                fileName, orderNumber, 'data.retailers[].amounts');
      }

      if (totalDifference > 0.02) {
        addIssue('warning', 'Retailer total sum mismatch',
                `Sum of retailer totals (${retailerTotalSum.toFixed(2)}) doesn't match the order total without platform fee (${orderTotalWithoutPlatform.toFixed(2)}), difference: ${totalDifference.toFixed(2)}`,
                fileName, orderNumber, 'data.retailers[].amounts');
      }
    }
  }

  // 5. Enhanced product data validation
  function checkProductData(data, fileName, orderNumber) {
    if (!data.items || !Array.isArray(data.items)) return;

    data.items.forEach((item, index) => {
      if (!item.product) {
        addIssue('error', 'Missing product data', `Item ${index + 1} is missing product data`, fileName, orderNumber, `data.items[${index}].product`);
        return;
      }

      const product = item.product;

      // Check product name
      if (!product.name) {
        addIssue('error', 'Missing product name', `Item ${index + 1} is missing product name`, fileName, orderNumber, `data.items[${index}].product.name`);
      }

      // Different validation for gift cards vs regular products
      if (isGiftCardProduct(product)) {
        // Gift card specific validation
        // Check gift card specific fields
        if (!item.attributes || !item.attributes.giftCard) {
          addIssue('error', 'Missing gift card attributes',
                  `Gift card product is missing required gift card attributes`,
                  fileName, orderNumber, `data.items[${index}].attributes.giftCard`);
        } else {
          const giftCard = item.attributes.giftCard;

          // Check for required recipient
          if (!giftCard.recipients || !giftCard.recipients.length) {
            addIssue('error', 'Missing gift card recipient',
                    `Gift card is missing required recipient email(s)`,
                    fileName, orderNumber, `data.items[${index}].attributes.giftCard.recipients`);
          }

          // Check send date
          if (!giftCard.sendDate) {
            addIssue('warning', 'Missing gift card send date',
                    `Gift card is missing send date`,
                    fileName, orderNumber, `data.items[${index}].attributes.giftCard.sendDate`);
          }

          // Check for sender
          if (!giftCard.sender) {
            addIssue('warning', 'Missing gift card sender',
                    `Gift card is missing sender name`,
                    fileName, orderNumber, `data.items[${index}].attributes.giftCard.sender`);
          }
        }

        // "NULL NULL" size is expected for gift cards
        if (product.size === "NULL NULL") {
          // This is acceptable for gift cards
        } else if (product.size && !validateSizeFormat(product.size)) {
          addIssue('info', 'Non-standard gift card size',
                  `Gift card has non-standard size format: "${product.size}"`,
                  fileName, orderNumber, `data.items[${index}].product.size`);
        }

        // UPC is not required for gift cards
        if (product.upc === '') {
          addIssue('info', 'Empty UPC for gift card',
                  `Gift card has empty UPC string instead of null or valid UPC`,
                  fileName, orderNumber, `data.items[${index}].product.upc`);
        }
      } else {
        // Regular product validations
        // Check UPC
        if (!product.upc) {
          addIssue('warning', 'Missing UPC code',
                  `Product "${product.name || 'unknown'}" is missing UPC code`,
                  fileName, orderNumber, `data.items[${index}].product.upc`);
        } else if (product.upc === '') {
          addIssue('warning', 'Empty UPC string',
                  `Product "${product.name || 'unknown'}" has empty UPC string instead of null or valid UPC`,
                  fileName, orderNumber, `data.items[${index}].product.upc`);
        }

        // Check for consistent size format
        if (product.size) {
          if (product.size === "NULL NULL") {
            addIssue('error', 'Invalid size format',
                    `Product "${product.name || 'unknown'}" has invalid "NULL NULL" size`,
                    fileName, orderNumber, `data.items[${index}].product.size`);
          } else if (!validateSizeFormat(product.size)) {
            addIssue('warning', 'Non-standard size format',
                    `Product has non-standard size format: "${product.size}"`,
                    fileName, orderNumber, `data.items[${index}].product.size`);
          }

          // Check consistency between size and volume
          if (product.volume && !product.size.includes(product.volume)) {
            addIssue('warning', 'Inconsistent size and volume',
                    `Item ${index + 1} has size (${product.size}) that doesn't match volume (${product.volume})`,
                    fileName, orderNumber, `data.items[${index}].product.size`);
          }
        }

        // Check alcohol-related attributes
        if (isAlcoholProduct(product)) {
          // Check if ABV is provided for alcohol products
          if (!product.attributes || !product.attributes.abv) {
            addIssue('warning', 'Missing ABV',
                    `Alcohol product (${product.name || 'Unnamed product'}) is missing ABV value`,
                    fileName, orderNumber, `data.items[${index}].product.attributes.abv`);
          } else if (product.attributes.abv === '') {
            addIssue('warning', 'Empty ABV string',
                    `Alcohol product has empty ABV string instead of numeric value`,
                    fileName, orderNumber, `data.items[${index}].product.attributes.abv`);
          }

          // Check if proof is provided for spirits
          if (product.category && product.category.toLowerCase().includes('spirits') && !product.proof) {
            addIssue('info', 'Missing proof',
                    `Spirit product (${product.name || 'Unnamed product'}) is missing proof value`,
                    fileName, orderNumber, `data.items[${index}].product.proof`);
          }

          // Check container type
          if (!product.attributes || !product.attributes.containerType) {
            addIssue('warning', 'Missing container type',
                    `Alcohol product (${product.name || 'Unnamed product'}) is missing container type`,
                    fileName, orderNumber, `data.items[${index}].product.attributes.containerType`);
          }
        }
      }

      // Image checks for all product types
      if (!item.image) {
        addIssue('warning', 'Missing product image',
                `Item ${index + 1} (${product.name || 'Unnamed product'}) is missing image URL`,
                fileName, orderNumber, `data.items[${index}].image`);
      } else if (!item.image.startsWith('http')) {
        addIssue('warning', 'Invalid image URL',
                `Item ${index + 1} has an invalid image URL format`,
                fileName, orderNumber, `data.items[${index}].image`);
      }

      // Validate pricing data for all product types
      if (!item.pricing) {
        addIssue('error', 'Missing pricing data',
                `Item ${index + 1} is missing pricing information`,
                fileName, orderNumber, `data.items[${index}].pricing`);
      } else {
        if (item.pricing.quantity <= 0) {
          addIssue('error', 'Invalid quantity',
                  `Item ${index + 1} has an invalid quantity (${item.pricing.quantity})`,
                  fileName, orderNumber, `data.items[${index}].pricing.quantity`);
        }

        if (item.pricing.unitPrice < 0) {
          addIssue('error', 'Negative unit price',
                  `Item ${index + 1} has a negative unit price (${item.pricing.unitPrice})`,
                  fileName, orderNumber, `data.items[${index}].pricing.unitPrice`);
        }

        // Check for consistent decimal places in pricing
        const priceString = item.pricing.price?.toString() || '';
        const unitPriceString = item.pricing.unitPrice?.toString() || '';

        if (priceString.includes('.') && priceString.split('.')[1].length !== 2) {
          addIssue('info', 'Non-standard price format',
                  `Item price (${priceString}) uses non-standard decimal places`,
                  fileName, orderNumber, `data.items[${index}].pricing.price`);
        }

        if (unitPriceString.includes('.') && unitPriceString.split('.')[1].length !== 2) {
          addIssue('info', 'Non-standard unit price format',
                  `Item unit price (${unitPriceString}) uses non-standard decimal places`,
                  fileName, orderNumber, `data.items[${index}].pricing.unitPrice`);
        }
      }
    });
  }

  // Helper function to validate size format
  function validateSizeFormat(size) {
    // Common formats: "750 ML", "700 ML", "1.75 L", etc.
    const standardFormats = [
      /^\d+(\.\d+)?\s?(ML|L|OZ|CL)$/i,  // 750 ML, 1.75 L
      /^(\d+)\s?x\s?(\d+(\.\d+)?)\s?(ML|L|OZ|CL)$/i // 6 x 750 ML (pack)
    ];

    return standardFormats.some(pattern => pattern.test(size));
  }

  // 6. Retailer data validation
  function checkRetailerData(data, fileName, orderNumber) {
    if (!data.retailers || !Array.isArray(data.retailers)) return;

    // Confirm all retailer IDs are included in the items
    const retailerIds = data.retailers.map(retailer => retailer.id);
    const itemRetailerIds = data.items ? data.items.map(item => item.retailerId) : [];

    // Check for retailers without any items
    retailerIds.forEach((retailerId, index) => {
      if (!itemRetailerIds.includes(retailerId)) {
        addIssue('warning', 'Orphaned retailer',
                `Retailer ${index + 1} (${data.retailers[index].name || 'Unnamed'}) has no associated items`,
                fileName, orderNumber, `data.retailers[${index}]`);
      }
    });

    // Check for items with non-existent retailers
    if (data.items) {
      data.items.forEach((item, index) => {
        if (item.retailerId && !retailerIds.includes(item.retailerId)) {
          addIssue('error', 'Invalid retailer reference',
                  `Item ${index + 1} references non-existent retailer ID: ${item.retailerId}`,
                  fileName, orderNumber, `data.items[${index}].retailerId`);
        }
      });
    }

    // Validate each retailer
    data.retailers.forEach((retailer, index) => {
      // Check required retailer fields
      if (!retailer.name) {
        addIssue('warning', 'Missing retailer name',
                `Retailer ${index + 1} is missing a name`,
                fileName, orderNumber, `data.retailers[${index}].name`);
      }

      if (!retailer.id) {
        addIssue('error', 'Missing retailer ID',
                `Retailer ${index + 1} is missing an ID`,
                fileName, orderNumber, `data.retailers[${index}].id`);
      }

      // Check ID format consistency
      if (retailer.id && retailer.legacyId) {
        const idType = detectIdType(retailer.id);
        const legacyIdType = detectIdType(retailer.legacyId.toString());

        if (idType !== legacyIdType && !(idType === 'ObjectId' && legacyIdType === 'numeric')) {
          addIssue('warning', 'Inconsistent ID format',
                  `Retailer ${index + 1} (${retailer.name || 'Unnamed'}) has inconsistent ID formats: ${idType} and ${legacyIdType}`,
                  fileName, orderNumber, `data.retailers[${index}]`);
        }
      }

      // Validate retailer address if present
      if (retailer.address) {
        const addr = retailer.address;

        // Check required address fields
        const requiredFields = ['one', 'city', 'state', 'zip'];
        requiredFields.forEach(field => {
          if (!addr[field]) {
            addIssue('warning', 'Missing retailer address field',
                    `Retailer ${index + 1} (${retailer.name || 'Unnamed'}) address is missing field: ${field}`,
                    fileName, orderNumber, `data.retailers[${index}].address.${field}`);
          }
        });

        // Check country consistency
        if (addr.country && data.addresses && data.addresses.shipping &&
                addr.country !== data.addresses.shipping.country) {
          addIssue('info', 'Cross-border shipment',
                  `Retailer ${index + 1} country (${addr.country}) differs from shipping country (${data.addresses.shipping.country})`,
                  fileName, orderNumber, `data.retailers[${index}].address.country`);
        }
      } else {
        addIssue('warning', 'Missing retailer address',
                `Retailer ${index + 1} (${retailer.name || 'Unnamed'}) is missing address information`,
                fileName, orderNumber, `data.retailers[${index}].address`);
      }

      // Check fulfillments
      if (!retailer.fulfillments || !Array.isArray(retailer.fulfillments) || retailer.fulfillments.length === 0) {
        addIssue('warning', 'Missing fulfillments',
                `Retailer ${index + 1} (${retailer.name || 'Unnamed'}) has no fulfillments`,
                fileName, orderNumber, `data.retailers[${index}].fulfillments`);
      }
    });
  }

  // 7. Fulfillment data validation
  function checkFulfillmentData(data, fileName, orderNumber) {
    if (!data.retailers || !Array.isArray(data.retailers)) return;

    // Collect all fulfillment IDs across retailers
    const fulfillmentIds = [];

    data.retailers.forEach((retailer, retailerIndex) => {
      if (!retailer.fulfillments || !Array.isArray(retailer.fulfillments)) return;

      retailer.fulfillments.forEach((fulfillment, fulfillmentIndex) => {
        if (fulfillment.id) {
          fulfillmentIds.push(fulfillment.id);
        } else {
          addIssue('error', 'Missing fulfillment ID',
                  `Retailer ${retailerIndex + 1} (${retailer.name || 'Unnamed'}) fulfillment ${fulfillmentIndex + 1} is missing an ID`,
                  fileName, orderNumber, `data.retailers[${retailerIndex}].fulfillments[${fulfillmentIndex}]`);
        }

        // Check fulfillment type
        if (!fulfillment.type) {
          addIssue('error', 'Missing fulfillment type',
                  `Fulfillment ${fulfillment.id || `index ${fulfillmentIndex}`} is missing type`,
                  fileName, orderNumber, `data.retailers[${retailerIndex}].fulfillments[${fulfillmentIndex}].type`);
        } else if (!['shipping', 'pickup', 'delivery', 'digital'].includes(fulfillment.type)) {
          addIssue('warning', 'Unknown fulfillment type',
                  `Fulfillment ${fulfillment.id || `index ${fulfillmentIndex}`} has unknown type: ${fulfillment.type}`,
                  fileName, orderNumber, `data.retailers[${retailerIndex}].fulfillments[${fulfillmentIndex}].type`);
        }

        // Check fulfillment status
        if (!fulfillment.status) {
          addIssue('warning', 'Missing fulfillment status',
                  `Fulfillment ${fulfillment.id || `index ${fulfillmentIndex}`} is missing status`,
                  fileName, orderNumber, `data.retailers[${retailerIndex}].fulfillments[${fulfillmentIndex}].status`);
        }

        // Check items associated with this fulfillment
        if (!fulfillment.itemIds || !Array.isArray(fulfillment.itemIds) || fulfillment.itemIds.length === 0) {
          addIssue('warning', 'Empty fulfillment',
                  `Fulfillment ${fulfillment.id || `index ${fulfillmentIndex}`} has no associated items`,
                  fileName, orderNumber, `data.retailers[${retailerIndex}].fulfillments[${fulfillmentIndex}].itemIds`);
        } else if (data.items) {
          // Check that all itemIds in the fulfillment actually exist in the order
          const orderItemIds = data.items.map(item => item.id);

          fulfillment.itemIds.forEach((itemId, i) => {
            if (!orderItemIds.includes(itemId)) {
              addIssue('error', 'Invalid item reference',
                      `Fulfillment ${fulfillment.id || `index ${fulfillmentIndex}`} references non-existent item ID: ${itemId}`,
                      fileName, orderNumber, `data.retailers[${retailerIndex}].fulfillments[${fulfillmentIndex}].itemIds[${i}]`);
            }
          });
        }

        // Check type-specific validation
        if (fulfillment.type === 'digital') {
          // Digital fulfillment validation
          // Check associated items are appropriate for digital fulfillment
          const digitalItems = data.items ? data.items.filter(item =>
                  fulfillment.itemIds.includes(item.id)
          ) : [];

          digitalItems.forEach(item => {
            if (item.product && !isGiftCardProduct(item.product) &&
                    !item.product.category?.toLowerCase().includes('digital')) {
              addIssue('error', 'Inappropriate digital fulfillment',
                      `Item "${item.product.name || item.id}" appears to be a physical product but has digital fulfillment`,
                      fileName, orderNumber, `data.items[${data.items.indexOf(item)}].fulfillmentId`);
            }
          });

          // Digital fulfillments should not have packages
          if (fulfillment.packages && fulfillment.packages.length > 0) {
            addIssue('warning', 'Unexpected packages',
                    `Digital fulfillment ${fulfillment.id} has physical packages defined`,
                    fileName, orderNumber, `data.retailers[${retailerIndex}].fulfillments[${fulfillmentIndex}].packages`);
          }
        } else if (fulfillment.type === 'shipping') {
          // Shipping fulfillment validation
          // Check for packages on shipping fulfillments with shipped/delivered status
          if ((['shipped', 'delivered'].includes(fulfillment.status)) &&
                  (!fulfillment.packages || !Array.isArray(fulfillment.packages) || fulfillment.packages.length === 0)) {
            addIssue('error', 'Missing packages',
                    `Shipping fulfillment ${fulfillment.id || `index ${fulfillmentIndex}`} with status "${fulfillment.status}" has no packages`,
                    fileName, orderNumber, `data.retailers[${retailerIndex}].fulfillments[${fulfillmentIndex}].packages`);
          } else if (fulfillment.packages && Array.isArray(fulfillment.packages)) {
            // Validate package information
            fulfillment.packages.forEach((pkg, pkgIndex) => {
              if (!pkg.trackingNumber && ['shipped', 'delivered'].includes(fulfillment.status)) {
                addIssue('error', 'Missing tracking number',
                        `Package ${pkgIndex + 1} is missing tracking number for a ${fulfillment.status} shipment`,
                        fileName, orderNumber, `data.retailers[${retailerIndex}].fulfillments[${fulfillmentIndex}].packages[${pkgIndex}].trackingNumber`);
              }

              if (!pkg.carrier && ['shipped', 'delivered'].includes(fulfillment.status)) {
                addIssue('warning', 'Missing carrier',
                        `Package ${pkgIndex + 1} is missing carrier information for a ${fulfillment.status} shipment`,
                        fileName, orderNumber, `data.retailers[${retailerIndex}].fulfillments[${fulfillmentIndex}].packages[${pkgIndex}].carrier`);
              }

              // Date validation for packages
              if (pkg.dateShipped) {
                const shippedDate = new Date(pkg.dateShipped);

                if (isNaN(shippedDate.getTime())) {
                  addIssue('error', 'Invalid shipped date',
                          `Package ${pkgIndex + 1} has invalid dateShipped: ${pkg.dateShipped}`,
                          fileName, orderNumber, `data.retailers[${retailerIndex}].fulfillments[${fulfillmentIndex}].packages[${pkgIndex}].dateShipped`);
                } else {
                  // Check against order date
                  const orderDate = data.createdAt ? new Date(data.createdAt) : null;

                  if (orderDate && shippedDate < orderDate) {
                    addIssue('error', 'Date inconsistency',
                            `Package shipped date (${pkg.dateShipped}) is before order creation date (${data.createdAt})`,
                            fileName, orderNumber, `data.retailers[${retailerIndex}].fulfillments[${fulfillmentIndex}].packages[${pkgIndex}].dateShipped`);
                  }

                  // Check if date is in the future
                  const now = new Date();
                  if (shippedDate > now && fulfillment.status !== 'pending') {
                    addIssue('warning', 'Future ship date',
                            `Package has a ship date (${pkg.dateShipped}) in the future but status is ${fulfillment.status}`,
                            fileName, orderNumber, `data.retailers[${retailerIndex}].fulfillments[${fulfillmentIndex}].packages[${pkgIndex}].dateShipped`);
                  }
                }
              } else if (['shipped', 'delivered'].includes(fulfillment.status)) {
                addIssue('warning', 'Missing ship date',
                        `Package ${pkgIndex + 1} is missing dateShipped for a ${fulfillment.status} shipment`,
                        fileName, orderNumber, `data.retailers[${retailerIndex}].fulfillments[${fulfillmentIndex}].packages[${pkgIndex}].dateShipped`);
              }

              // Check timeline consistency
              if (pkg.timeline && Array.isArray(pkg.timeline) && pkg.timeline.length > 0) {
                // Get the latest status in the timeline
                const latestStatus = pkg.timeline[0].status;

                if (latestStatus !== pkg.status) {
                  addIssue('warning', 'Inconsistent package status',
                          `Package ${pkgIndex + 1} status (${pkg.status}) doesn't match latest timeline status (${latestStatus})`,
                          fileName, orderNumber, `data.retailers[${retailerIndex}].fulfillments[${fulfillmentIndex}].packages[${pkgIndex}].status`);
                }

                // Check for timeline date inconsistencies
                let prevDate = null;
                pkg.timeline.forEach((entry, entryIndex) => {
                  if (!entry.timestamp) {
                    addIssue('warning', 'Missing timeline timestamp',
                            `Package ${pkgIndex + 1} timeline entry ${entryIndex + 1} is missing timestamp`,
                            fileName, orderNumber, `data.retailers[${retailerIndex}].fulfillments[${fulfillmentIndex}].packages[${pkgIndex}].timeline[${entryIndex}]`);
                  } else {
                    const entryDate = new Date(entry.timestamp);

                    if (isNaN(entryDate.getTime())) {
                      addIssue('warning', 'Invalid timeline timestamp',
                              `Package ${pkgIndex + 1} timeline entry ${entryIndex + 1} has invalid timestamp: ${entry.timestamp}`,
                              fileName, orderNumber, `data.retailers[${retailerIndex}].fulfillments[${fulfillmentIndex}].packages[${pkgIndex}].timeline[${entryIndex}].timestamp`);
                    } else if (prevDate && entryDate > prevDate) {
                      // Timeline should be in reverse chronological order (newest first)
                      addIssue('warning', 'Timeline order inconsistency',
                              `Package ${pkgIndex + 1} timeline entries are not in reverse chronological order`,
                              fileName, orderNumber, `data.retailers[${retailerIndex}].fulfillments[${fulfillmentIndex}].packages[${pkgIndex}].timeline`);
                    }

                    prevDate = entryDate;
                  }
                });
              }
            });
          }
        }
      });
    });

    // Check for items without fulfillment
    if (data.items) {
      data.items.forEach((item, index) => {
        if (!item.fulfillmentId) {
          addIssue('error', 'Missing fulfillment reference',
                  `Item ${index + 1} (${item.product?.name || 'Unnamed product'}) doesn't reference a fulfillment`,
                  fileName, orderNumber, `data.items[${index}].fulfillmentId`);
        } else if (!fulfillmentIds.includes(item.fulfillmentId)) {
          addIssue('error', 'Invalid fulfillment reference',
                  `Item ${index + 1} references non-existent fulfillment ID: ${item.fulfillmentId}`,
                  fileName, orderNumber, `data.items[${index}].fulfillmentId`);
        }
      });
    }
  }

  // 6. Enhanced check for empty strings vs null values
  function checkEmptyVsNull(data, fileName, orderNumber) {
    // Define paths to check
    const checkPaths = [
      { path: 'customer.phone', description: 'Customer phone' },
      { path: 'customer.birthdate', description: 'Customer birthdate' },
      { path: 'addresses.shipping.two', description: 'Shipping address line 2' },
      { path: 'addresses.billing.two', description: 'Billing address line 2' },
      { path: 'addresses.billing.company', description: 'Billing company' },
      { path: 'options.giftMessage', description: 'Gift message' }
    ];

    checkPaths.forEach(({ path, description }) => {
      const parts = path.split('.');
      let current = data;
      let valid = true;

      // Navigate to the nested property
      for (let i = 0; i < parts.length; i++) {
        const part = parts[i];
        if (current === undefined || current === null) {
          valid = false;
          break;
        }
        if (i === parts.length - 1) {
          // Check the final property
          if (current[part] === '') {
            addIssue('info', 'Empty string vs null',
                    `${description} is an empty string "" instead of null`,
                    fileName, orderNumber, `data.${path}`);
          }
        } else {
          current = current[part];
        }
      }
    });

    // Check for empty arrays that should be null
    const arrayPaths = [
      { path: 'items', description: 'Order items' },
      { path: 'retailers', description: 'Order retailers' }
    ];

    arrayPaths.forEach(({ path, description }) => {
      if (Array.isArray(data[path]) && data[path].length === 0) {
        addIssue('info', 'Empty array vs null',
                `${description} is an empty array [] instead of null or having entries`,
                fileName, orderNumber, `data.${path}`);
      }
    });
  }

  // 8. Metadata and options validation
  function checkMetadataAndOptions(data, fileName, orderNumber) {
    // Check options
    if (data.options) {
      // Age verification for alcohol orders
      const hasAlcoholProducts = data.items && data.items.some(item => isAlcoholProduct(item.product));

      if (hasAlcoholProducts && data.options.hasVerifiedAge !== true) {
        addIssue('error', 'Missing age verification',
                'Order contains alcohol products but age verification flag is not set to true',
                fileName, orderNumber, 'data.options.hasVerifiedAge');
      }

      // Gift order consistency
      if (data.options.isGift === true) {
        // Check gift recipient info
        if (!data.options.giftRecipient ||
                !data.options.giftRecipient.name ||
                !data.options.giftRecipient.email) {
          addIssue('warning', 'Incomplete gift recipient',
                  'Order is marked as a gift but has incomplete gift recipient information',
                  fileName, orderNumber, 'data.options.giftRecipient');
        }

        // For gift orders, check if gift message is present
        if (!data.options.giftMessage) {
          addIssue('info', 'Missing gift message',
                  'Order is marked as a gift but has no gift message',
                  fileName, orderNumber, 'data.options.giftMessage');
        }
      } else if (data.options.isGift === false) {
        // Check if gift message is present despite not being a gift
        if (data.options.giftMessage && data.options.giftMessage.trim().length > 0) {
          addIssue('warning', 'Inconsistent gift settings',
                  'Order is not marked as a gift but has a gift message',
                  fileName, orderNumber, 'data.options.giftMessage');
        }

        // Check if gift recipient info is present despite not being a gift
        if (data.options.giftRecipient &&
                (data.options.giftRecipient.name || data.options.giftRecipient.email || data.options.giftRecipient.phone)) {
          addIssue('warning', 'Inconsistent gift settings',
                  'Order is not marked as a gift but has gift recipient information',
                  fileName, orderNumber, 'data.options.giftRecipient');
        }
      }
    } else {
      addIssue('error', 'Missing options', 'Order is missing options field', fileName, orderNumber, 'data.options');
    }

    // Check metadata
    if (data.metadata) {
      // This would be specific to your system's metadata requirements
      // Example: checking request ID format, timestamp validity, etc.
    }
  }

  // 9. Cross-field dependencies
  function checkCrossFieldDependencies(data, fileName, orderNumber) {
    // Check order dates vs fulfillment dates logic
    const orderCreated = data.createdAt ? new Date(data.createdAt) : null;

    if (orderCreated && data.retailers && Array.isArray(data.retailers)) {
      data.retailers.forEach((retailer, rIndex) => {
        if (retailer.fulfillments && Array.isArray(retailer.fulfillments)) {
          retailer.fulfillments.forEach((fulfillment, fIndex) => {
            if (fulfillment.packages && Array.isArray(fulfillment.packages)) {
              fulfillment.packages.forEach((pkg, pIndex) => {
                if (pkg.dateShipped) {
                  const shippedDate = new Date(pkg.dateShipped);

                  if (!isNaN(shippedDate.getTime()) && shippedDate < orderCreated) {
                    addIssue('error', 'Date inconsistency',
                            `Package shipped date (${pkg.dateShipped}) is before order creation date (${data.createdAt})`,
                            fileName, orderNumber, `data.retailers[${rIndex}].fulfillments[${fIndex}].packages[${pIndex}].dateShipped`);
                  }
                }
              });
            }
          });
        }
      });
    }

    // Check item placement vs fulfillment status logic
    if (data.items && Array.isArray(data.items)) {
      data.items.forEach((item, itemIndex) => {
        const placement = item.customerPlacement;

        if (placement === 'pre_sale' || placement === 'back_order') {
          // Find the associated fulfillment
          let fulfillment = null;
          let retailerIndex = -1;
          let fulfillmentIndex = -1;

          if (data.retailers && Array.isArray(data.retailers)) {
            data.retailers.forEach((retailer, rIndex) => {
              if (retailer.fulfillments && Array.isArray(retailer.fulfillments)) {
                const foundFulfillment = retailer.fulfillments.findIndex(f => f.id === item.fulfillmentId);

                if (foundFulfillment !== -1) {
                  fulfillment = retailer.fulfillments[foundFulfillment];
                  retailerIndex = rIndex;
                  fulfillmentIndex = foundFulfillment;
                }
              }
            });
          }

          if (fulfillment && ['shipped', 'delivered'].includes(fulfillment.status)) {
            // Check if the order is recent (within last 30 days)
            const orderDate = new Date(data.createdAt);
            const now = new Date();
            const daysSinceOrder = (now - orderDate) / (1000 * 60 * 60 * 24);

            // Only flag if order is relatively recent (within 30 days)
            if (daysSinceOrder <= 30) {
              const issueLevel = fulfillment.status === 'delivered' ? 'error' : 'warning';

              addIssue(issueLevel, 'Placement status inconsistency',
                      `Item marked as ${placement} but fulfillment status is ${fulfillment.status}`,
                      fileName, orderNumber, `data.items[${itemIndex}].customerPlacement`);
            }
          }
        }
      });
    }

    // Check gift card items vs gift info consistency
    const hasGiftCardItem = data.items && data.items.some(item =>
            item.product && isGiftCardProduct(item.product)
    );

    if (hasGiftCardItem && data.options && data.options.isGift === true) {
      addIssue('info', 'Gift card in gift order',
              'Order contains gift card items and is also marked as a gift order',
              fileName, orderNumber, 'data.options.isGift');
    }
  }

  // Helper function to detect ID type
  function detectIdType(id) {
    if (typeof id !== 'string' && typeof id !== 'number') {
      return 'unknown';
    }

    const strId = id.toString();

    if (/^\d+$/.test(strId)) {
      return 'numeric';
    } else if (/^[0-9a-f]{24}$/.test(strId)) {
      return 'ObjectId';
    } else {
      return 'other';
    }
  }

  // Helper function to check if a product is a gift card
  function isGiftCardProduct(product) {
    if (!product) return false;

    return (
            (product.name && product.name.toLowerCase().includes('gift card')) ||
            (product.category && product.category.toLowerCase().includes('gift card'))
    );
  }

  // Helper function to check if a product is an alcohol product
  function isAlcoholProduct(product) {
    if (!product) return false;

    return (
            (product.category && (
                    product.category.toLowerCase().includes('spirits') ||
                    product.category.toLowerCase().includes('wine') ||
                    product.category.toLowerCase().includes('beer')
            )) ||
            (product.attributes && product.attributes.abv && parseFloat(product.attributes.abv) > 0)
    );
  }

  // Enhanced recommendations generation
  function generateRecommendations() {
    // Reset recommendations
    validationResults.recommendations = [];

    // Count issues by type and category
    const issueCounts = {
      error: 0,
      warning: 0,
      info: 0,
      categories: {
        structure: 0,
        customer: 0,
        address: 0,
        financial: 0,
        product: 0,
        retailer: 0,
        fulfillment: 0,
        options: 0
      }
    };

    // Categorize issues
    validationResults.issues.forEach(issue => {
      // Count by severity
      issueCounts[issue.severity]++;

      // Count by category based on path
      const path = issue.path || '';

      if (path.includes('customer')) {
        issueCounts.categories.customer++;
      } else if (path.includes('addresses')) {
        issueCounts.categories.address++;
      } else if (path.includes('amounts') || path.includes('pricing')) {
        issueCounts.categories.financial++;
      } else if (path.includes('product') || path.includes('items')) {
        issueCounts.categories.product++;
      } else if (path.includes('retailers')) {
        issueCounts.categories.retailer++;
      } else if (path.includes('fulfillment') || path.includes('packages')) {
        issueCounts.categories.fulfillment++;
      } else if (path.includes('options')) {
        issueCounts.categories.options++;
      } else {
        issueCounts.categories.structure++;
      }
    });

    // Generate standard recommendations
    addRecommendation(
            'rec-structure-1',
            'Standardize API response structure',
            'Ensure all order responses follow a consistent structure with all required fields present.',
            issueCounts.categories.structure > 0 ? 'high' : 'medium'
    );

    addRecommendation(
            'rec-financial-1',
            'Implement precise amount calculations',
            'Use fixed-precision decimal calculations for all financial values to avoid floating-point errors in totals.',
            issueCounts.categories.financial > 0 ? 'high' : 'medium'
    );

    // Add ID format recommendation if there are issues
    if (validationResults.issues.some(issue => issue.title?.includes('ID format'))) {
      addRecommendation(
              'rec-structure-2',
              'Standardize ID formats',
              'Use consistent ID formats across all entities in the API response. Choose either numeric IDs or ObjectIDs and apply them consistently throughout the system.',
              'high'
      );
    }

    // Address validation recommendations
    if (issueCounts.categories.address > 0) {
      addRecommendation(
              'rec-address-1',
              'Enhance address validation',
              'Implement comprehensive address validation including format checks for postal codes, detection of P.O. boxes, and consistency between shipping and billing addresses when the billingSameAsShipping flag is true.',
              'high'
      );

      addRecommendation(
              'rec-address-2',
              'Normalize country and state codes',
              'Standardize country codes (use ISO 3166-1 alpha-2) and state/province codes across all addresses in the system.',
              'medium'
      );
    }

    // Product recommendations
    if (issueCounts.categories.product > 0) {
      addRecommendation(
              'rec-product-1',
              'Enforce complete product data',
              'Require all products to have complete information including name, UPC (for non-gift cards), proper size formatting, and category-specific attributes.',
              'high'
      );

      // Alcohol-specific recommendations
      if (validationResults.issues.some(issue => issue.description?.includes('alcohol'))) {
        addRecommendation(
                'rec-product-2',
                'Improve alcohol product validation',
                'For alcohol products, enforce ABV, proof, and container type information, and ensure age verification is always completed.',
                'high'
        );
      }

      // Gift card specific recommendations
      if (validationResults.issues.some(issue => issue.description?.includes('gift card'))) {
        addRecommendation(
                'rec-product-3',
                'Enhance gift card validation',
                'Ensure all gift cards have complete information including recipient email, send date, and sender information.',
                'high'
        );
      }
    }

    // Customer data recommendations
    if (issueCounts.categories.customer > 0) {
      addRecommendation(
              'rec-customer-1',
              'Validate customer information',
              'Implement comprehensive validation for customer data including email format, name consistency between customer and billing information, and birthdate validation for alcohol orders.',
              'high'
      );
    }

    // Fulfillment recommendations
    if (issueCounts.categories.fulfillment > 0) {
      addRecommendation(
              'rec-fulfillment-1',
              'Improve fulfillment tracking',
              'Enhance fulfillment validation to ensure all items have valid fulfillments, packages have proper tracking information, and dates are consistent with order lifecycle.',
              'high'
      );

      addRecommendation(
              'rec-fulfillment-2',
              'Validate digital fulfillments',
              'Ensure digital fulfillments are only used for appropriate products like gift cards and digital content.',
              'medium'
      );
    }

    // Options recommendations
    if (issueCounts.categories.options > 0) {
      addRecommendation(
              'rec-options-1',
              'Consistent order options',
              'Ensure gift settings, age verification, and delivery instructions are consistently applied based on order context and contents.',
              'medium'
      );
    }

    // System-wide recommendations
    addRecommendation(
            'rec-system-1',
            'Implement date consistency checks',
            'Add system-wide validation to ensure all dates follow a consistent format and maintain logical chronological order (e.g., shipping dates cannot be before order dates).',
            'medium'
    );

    addRecommendation(
            'rec-system-2',
            'Cross-entity validation',
            'Implement validation checks across different entities to ensure consistency (e.g., retailer amounts sum matches order total, all items have valid fulfillments).',
            'high'
    );

    // Add implementation recommendations
    addRecommendation(
            'rec-impl-1',
            'Server-side validation',
            'Implement comprehensive server-side validation before saving orders to ensure data integrity across the system.',
            'high'
    );

    addRecommendation(
            'rec-impl-2',
            'Validation error codes',
            'Add specific error codes to each validation issue to help with troubleshooting and creating automated tests.',
            'medium'
    );
  }

  // Helper function to add a recommendation
  function addRecommendation(id, title, description, priority) {
    validationResults.recommendations.push({
      id,
      title,
      description,
      priority
    });
  }

  // Update UI with validation results
  function updateResults() {
    // Update stats
    updateStats();

    // Update issues list
    issuesList.innerHTML = '';
    if (validationResults.issues.length === 0) {
      issuesList.innerHTML = `
        <div class="card text-center py-8">
          <i class="fas fa-check-circle text-success text-4xl mb-4"></i>
          <h3 class="text-xl font-medium">No issues found</h3>
          <p class="text-gray">All orders passed validation checks.</p>
        </div>
      `;
    } else {
      // Group issues by severity
      const issuesBySeverity = {
        error: validationResults.issues.filter(issue => issue.severity === 'error'),
        warning: validationResults.issues.filter(issue => issue.severity === 'warning'),
        info: validationResults.issues.filter(issue => issue.severity === 'info')
      };

      // Create filter controls
      const filterControls = `
        <div class="mb-4 flex justify-center">
          <div class="filter-group">
            <button class="filter-btn active" data-filter="all">All</button>
            <button class="filter-btn" data-filter="error">Errors</button>
            <button class="filter-btn" data-filter="warning">Warnings</button>
            <button class="filter-btn" data-filter="info">Info</button>
          </div>
        </div>
      `;
      issuesList.innerHTML = filterControls;

      // Add issues by severity
      ['error', 'warning', 'info'].forEach(severity => {
        if (issuesBySeverity[severity].length > 0) {
          const severityHeader = document.createElement('div');
          severityHeader.className = 'mb-4';
          severityHeader.innerHTML = `
            <h3 class="text-lg font-medium mb-2 flex items-center">
              <i class="fas fa-${severity === 'error' ? 'times-circle text-error' : severity === 'warning' ? 'exclamation-triangle text-warning' : 'info-circle text-info'} mr-2"></i>
              ${severity === 'error' ? 'Errors' : severity === 'warning' ? 'Warnings' : 'Information'}
              <span class="badge badge-${severity} ml-2">${issuesBySeverity[severity].length}</span>
            </h3>
          `;
          issuesList.appendChild(severityHeader);

          const issuesContainer = document.createElement('div');
          issuesContainer.className = 'space-y-4 mb-6 grid md:grid-cols-1 gap-4';

          issuesBySeverity[severity].forEach(issue => {
            const issueCard = document.createElement('div');
            issueCard.className = `card p-4 border-l-4 border-${severity === 'error' ? 'red' : severity === 'warning' ? 'amber' : 'blue'}-500`;
            issueCard.dataset.issueId = issue.id;
            issueCard.dataset.severity = issue.severity;
            issueCard.dataset.orderNumber = issue.orderNumber;

            issueCard.innerHTML = `
              <div class="flex justify-between items-center mb-2 issue-header">
                <h4 class="font-medium">${issue.title}</h4>
                <span class="badge badge-${issue.severity}">
                  <i class="fas fa-${severity === 'error' ? 'times-circle' : severity === 'warning' ? 'exclamation-triangle' : 'info-circle'}"></i>
                  ${severity.charAt(0).toUpperCase() + severity.slice(1)}
                </span>
              </div>
              <p class="mb-2">${issue.description}</p>
              <div class="text-sm text-gray flex items-center">
                <i class="fas fa-shopping-cart mr-2"></i>
                <span>Order #${issue.orderNumber}</span>
                ${issue.path ? `<span class="ml-2 px-2 py-1 bg-gray-100 rounded-md"><code>${issue.path}</code></span>` : ''}
              </div>
            `;

            // Add event listener to highlight issue
            issueCard.addEventListener('click', () => {
              document.querySelectorAll('.issue').forEach(card => card.classList.remove('highlighted-issue'));
              issueCard.classList.add('highlighted-issue');

              // Show order data with the path highlighted
              showOrderDetails(issue.orderNumber, issue.path);
            });

            issuesContainer.appendChild(issueCard);
          });

          issuesList.appendChild(issuesContainer);
        }
      });

      // Add filter functionality
      document.querySelectorAll('.filter-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          // Update active button
          document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');

          // Filter issues
          const filter = btn.getAttribute('data-filter');
          document.querySelectorAll('[data-severity]').forEach(issue => {
            if (filter === 'all' || issue.getAttribute('data-severity') === filter) {
              issue.style.display = 'block';
            } else {
              issue.style.display = 'none';
            }
          });
        });
      });
    }

    // Update recommendations
    recommendationsList.innerHTML = '';
    if (validationResults.recommendations.length === 0) {
      recommendationsList.innerHTML = `
        <div class="card">
          <p>No recommendations available.</p>
        </div>
      `;
    } else {
      validationResults.recommendations.forEach(recommendation => {
        const recommendationCard = document.createElement('div');
        recommendationCard.className = 'card';
        recommendationCard.innerHTML = `
          <h3 class="text-lg font-medium mb-2">${recommendation.title}</h3>
          <p class="mb-4">${recommendation.description}</p>
          ${recommendation.solution ? `
            <div class="solution">
              <h4 class="font-medium mb-1">Recommended solution:</h4>
              <p>${recommendation.solution}</p>
            </div>
          ` : ''}
        `;
        recommendationsList.appendChild(recommendationCard);
      });
    }
  }

  // Update stats section
  function updateStats() {
    const countBySeverity = {
      error: validationResults.issues.filter(i => i.severity === 'error').length,
      warning: validationResults.issues.filter(i => i.severity === 'warning').length,
      info: validationResults.issues.filter(i => i.severity === 'info').length
    };

    const totalIssues = countBySeverity.error + countBySeverity.warning + countBySeverity.info;
    const issuePercentage = totalIssues > 0
            ? Math.round((countBySeverity.error / totalIssues) * 100)
            : 0;

    // Count issues by category
    const categoryCounts = {
      structure: 0,
      customer: 0,
      address: 0,
      financial: 0,
      product: 0,
      retailer: 0,
      fulfillment: 0,
      options: 0
    };

    validationResults.issues.forEach(issue => {
      const path = issue.path || '';

      if (path.includes('customer')) {
        categoryCounts.customer++;
      } else if (path.includes('addresses')) {
        categoryCounts.address++;
      } else if (path.includes('amounts') || path.includes('pricing')) {
        categoryCounts.financial++;
      } else if (path.includes('product') || path.includes('items')) {
        categoryCounts.product++;
      } else if (path.includes('retailers')) {
        categoryCounts.retailer++;
      } else if (path.includes('fulfillment') || path.includes('packages')) {
        categoryCounts.fulfillment++;
      } else if (path.includes('options')) {
        categoryCounts.options++;
      } else {
        categoryCounts.structure++;
      }
    });

    // Prepare top issue categories
    const sortedCategories = Object.entries(categoryCounts)
            .sort((a, b) => b[1] - a[1])
            .slice(0, 3)
            .filter(category => category[1] > 0)
            .map(([category, count]) => `${categoryNameMap[category] || category} (${count})`);

    // Construct health score (simple version - could be more sophisticated)
    let healthScore = 100;

    // Deduct points based on issue severity
    healthScore -= (countBySeverity.error * 5);
    healthScore -= (countBySeverity.warning * 2);
    healthScore -= (countBySeverity.info * 0.5);

    // Ensure the score stays within 0-100 range
    healthScore = Math.max(0, Math.min(100, healthScore));

    // Update the stats grid with enhanced metrics
    statsGrid.innerHTML = `
    <div class="stat-card">
      <div class="flex items-center gap-2">
        <div class="stat-icon ${healthScore > 80 ? 'text-success' : (healthScore > 60 ? 'text-warning' : 'text-error')}">
          <i class="fas fa-heartbeat"></i>
        </div>
        <div class="text-2xl font-bold">${Math.round(healthScore)}</div>
      </div>
      <div class="text-sm text-gray">Health Score</div>
    </div>

    <div class="stat-card">
      <div class="flex items-center gap-2">
        <div class="stat-icon text-error">
          <i class="fas fa-exclamation-circle"></i>
        </div>
        <div class="text-2xl font-bold">${countBySeverity.error}</div>
      </div>
      <div class="text-sm text-gray">Critical Issues</div>
    </div>

    <div class="stat-card">
      <div class="flex items-center gap-2">
        <div class="stat-icon text-warning">
          <i class="fas fa-exclamation-triangle"></i>
        </div>
        <div class="text-2xl font-bold">${countBySeverity.warning}</div>
      </div>
      <div class="text-sm text-gray">Warnings</div>
    </div>

    <div class="stat-card">
      <div class="flex items-center gap-2">
        <div class="stat-icon text-info">
          <i class="fas fa-info-circle"></i>
        </div>
        <div class="text-2xl font-bold">${countBySeverity.info}</div>
      </div>
      <div class="text-sm text-gray">Suggestions</div>
    </div>

    <div class="stat-card">
      <div class="flex items-center gap-2">
        <div class="stat-icon text-primary">
          <i class="fas fa-chart-pie"></i>
        </div>
        <div class="text-xl">
          ${sortedCategories.length > 0
            ? sortedCategories.join('<br>')
            : '<span class="text-success">No issues found</span>'}
        </div>
      </div>
      <div class="text-sm text-gray">Top Issue Categories</div>
    </div>

    <div class="stat-card">
      <div class="flex items-center gap-2">
        <div class="stat-icon ${issuePercentage > 30 ? 'text-error' : (issuePercentage > 15 ? 'text-warning' : 'text-success')}">
          <i class="fas fa-file-alt"></i>
        </div>
        <div class="text-2xl font-bold">${validationResults.orders.length}</div>
      </div>
      <div class="text-sm text-gray">Orders Analyzed</div>
      ${totalIssues > 0
            ? `<div class="text-xs text-gray mt-1">${issuePercentage}% critical issue rate</div>`
            : ''}
    </div>
  `;
  }

  // Get suggested solution based on issue type
  function getSuggestedSolution(issue) {
    // Generate solutions based on the issue type and path
    if (issue.path?.includes('total')) {
      return 'Verify the calculation logic for totals. Ensure all components (subtotal, tax, shipping, etc.) are correctly summed.';
    } else if (issue.path?.includes('hasVerifiedAge')) {
      return 'Implement age verification checks for all orders with alcohol products. Update the hasVerifiedAge flag accordingly.';
    } else if (issue.path?.includes('product.upc')) {
      return 'Add UPC code for this product. All non-gift card products should have a UPC code for proper inventory tracking.';
    } else if (issue.description?.includes('typo')) {
      return 'Check for possible typos in customer information between billing address and customer profile.';
    } else if (issue.path?.includes('billingSameAsShipping')) {
      return 'Ensure the billingSameAsShipping flag correctly reflects whether the billing and shipping addresses are identical.';
    } else if (issue.title?.includes('ID format')) {
      return 'Standardize ID formats across the system. Use either numeric IDs or ObjectIDs consistently.';
    } else {
      return 'Review the data and ensure it follows the expected format and validation rules.';
    }
  }

  // Helper function to get top issue categories
  function getTopCategories(limit = 3) {
    // Count issues by category
    const categoryCounts = {};

    validationResults.issues.forEach(issue => {
      const path = issue.path || '';
      let category = 'structure';

      if (path.includes('customer')) {
        category = 'customer';
      } else if (path.includes('addresses')) {
        category = 'address';
      } else if (path.includes('amounts') || path.includes('pricing')) {
        category = 'financial';
      } else if (path.includes('product') || path.includes('items')) {
        category = 'product';
      } else if (path.includes('retailers')) {
        category = 'retailer';
      } else if (path.includes('fulfillment') || path.includes('packages')) {
        category = 'fulfillment';
      } else if (path.includes('options')) {
        category = 'options';
      }

      categoryCounts[category] = (categoryCounts[category] || 0) + 1;
    });

    // Convert to array and sort
    return Object.entries(categoryCounts)
            .map(([key, count]) => ({
              key,
              name: categoryNameMap[key] || key,
              count
            }))
            .sort((a, b) => b.count - a.count)
            .slice(0, limit);
  }

  // Initialize export buttons and functionality
  function initializeExports() {
    // Export as JSON
    document.getElementById('exportJsonBtn').addEventListener('click', () => {
      const includeRecommendations = document.getElementById('includeRecommendations').checked;

      const exportData = {
        summary: generateExportSummary(),
        orders: validationResults.orders.map(order => ({
          fileName: order.fileName,
          orderNumber: order.orderNumber
        })),
        issues: validationResults.issues
      };

      if (includeRecommendations) {
        exportData.recommendations = validationResults.recommendations;
      }

      const data = JSON.stringify(exportData, null, 2);
      downloadFile('order-validation-report.json', data, 'application/json');
    });

    // Export as CSV
    document.getElementById('exportCsvBtn').addEventListener('click', () => {
      // Create CSV for issues
      const headers = ['Severity', 'Title', 'Description', 'Order Number', 'File Name', 'Path', 'Category'];
      const csvRows = [headers];

      validationResults.issues.forEach(issue => {
        // Determine category from path
        const path = issue.path || '';
        let category = 'Structure';

        if (path.includes('customer')) {
          category = 'Customer Data';
        } else if (path.includes('addresses')) {
          category = 'Addressing';
        } else if (path.includes('amounts') || path.includes('pricing')) {
          category = 'Financial';
        } else if (path.includes('product') || path.includes('items')) {
          category = 'Product Data';
        } else if (path.includes('retailers')) {
          category = 'Retailer';
        } else if (path.includes('fulfillment') || path.includes('packages')) {
          category = 'Fulfillment';
        } else if (path.includes('options')) {
          category = 'Order Options';
        }

        csvRows.push([
          issue.severity,
          issue.title,
          issue.description,
          issue.orderNumber,
          issue.fileName,
          issue.path,
          category
        ]);
      });

      const csvContent = csvRows.map(row =>
              row.map(cell => `"${(cell || '').toString().replace(/"/g, '""')}"`).join(',')
      ).join('\n');

      downloadFile('order-validation-issues.csv', csvContent, 'text/csv');

      // If recommendations are included, export them as a separate CSV
      if (document.getElementById('includeRecommendations').checked) {
        const recHeaders = ['Priority', 'Category', 'Title', 'Description'];
        const recRows = [recHeaders];

        validationResults.recommendations.forEach(rec => {
          // Extract category from ID
          const category = rec.id.split('-')[1];
          const categoryName = categoryNameMap[category] || 'General';

          recRows.push([
            rec.priority,
            categoryName,
            rec.title,
            rec.description
          ]);
        });

        const recCsvContent = recRows.map(row =>
                row.map(cell => `"${(cell || '').toString().replace(/"/g, '""')}"`).join(',')
        ).join('\n');

        downloadFile('order-validation-recommendations.csv', recCsvContent, 'text/csv');
      }
    });

    // Export as PDF
    document.getElementById('exportPdfBtn').addEventListener('click', () => {
      // Show a message about PDF generation since we don't have full PDF generation capabilities in this demo
      alert('PDF export would generate a formatted PDF report including all issues, statistics, and optionally recommendations. This feature requires a PDF generation library like jsPDF or a server-side solution.');
    });

    // Export summary
    document.getElementById('exportSummaryBtn').addEventListener('click', () => {
      const summary = generateExportSummary();
      const summaryText =
              `Order API Validation Summary
===========================

Generated on: ${new Date().toLocaleString()}

Orders Analyzed: ${summary.ordersCount}
Total Issues: ${summary.totalIssues}
  - Critical Issues: ${summary.errorCount}
  - Warnings: ${summary.warningCount}
  - Suggestions: ${summary.infoCount}

Top Issue Categories:
${summary.topCategories.map(c => `  - ${c.name}: ${c.count} issues`).join('\n')}

Health Score: ${summary.healthScore}/100

Issue Rate: ${summary.issueRate.toFixed(2)}%

${document.getElementById('includeRecommendations').checked ?
                      `Top Recommendations:
${validationResults.recommendations
                              .filter(rec => rec.priority === 'high')
                              .slice(0, 3)
                              .map(rec => `  - ${rec.title}: ${rec.description}`)
                              .join('\n')}` : ''}
`;

      downloadFile('order-validation-summary.txt', summaryText, 'text/plain');
    });
  }

  // Generate export summary
  function generateExportSummary() {
    const errorCount = validationResults.issues.filter(i => i.severity === 'error').length;
    const warningCount = validationResults.issues.filter(i => i.severity === 'warning').length;
    const infoCount = validationResults.issues.filter(i => i.severity === 'info').length;
    const totalIssues = errorCount + warningCount + infoCount;

    // Calculate health score
    let healthScore = 100;
    healthScore -= (errorCount * 5);
    healthScore -= (warningCount * 2);
    healthScore -= (infoCount * 0.5);
    healthScore = Math.max(0, Math.min(100, healthScore));

    // Calculate issue rate (issues per order)
    const issueRate = validationResults.orders.length > 0
            ? (totalIssues / validationResults.orders.length) * 100
            : 0;

    return {
      timestamp: new Date().toISOString(),
      ordersCount: validationResults.orders.length,
      totalIssues,
      errorCount,
      warningCount,
      infoCount,
      healthScore: Math.round(healthScore),
      issueRate,
      topCategories: getTopCategories(5)
    };
  }

  // Update recommendations list
  function updateRecommendationsList() {
    recommendationsList.innerHTML = '';

    validationResults.recommendations.forEach(rec => {
      const recElement = document.createElement('div');
      recElement.className = 'card';

      const priorityBadge = rec.priority === 'high'
              ? '<span class="badge badge-error">High Priority</span>'
              : (rec.priority === 'medium' ? '<span class="badge badge-warning">Medium Priority</span>' : '<span class="badge badge-info">Low Priority</span>');

      recElement.innerHTML = `
            <div class="flex justify-between items-start mb-4">
                <h3 class="text-lg font-medium">${rec.title}</h3>
                ${priorityBadge}
            </div>
            <p>${rec.description}</p>
        `;

      recommendationsList.appendChild(recElement);
    });
  }

  // Export functionality
  exportJsonBtn.addEventListener('click', () => {
    const data = JSON.stringify(validationResults, null, 2);
    downloadFile('order-validation-report.json', data, 'application/json');
  });

  exportCsvBtn.addEventListener('click', () => {
    // Create CSV for issues
    const headers = ['Severity', 'Title', 'Description', 'Order Number', 'File Name', 'Path'];
    const csvRows = [headers];

    validationResults.issues.forEach(issue => {
      csvRows.push([
        issue.severity,
        issue.title,
        issue.description,
        issue.orderNumber,
        issue.fileName,
        issue.path
      ]);
    });

    const csvContent = csvRows.map(row =>
            row.map(cell => `"${(cell || '').toString().replace(/"/g, '""')}"`).join(',')
    ).join('\n');

    downloadFile('order-validation-issues.csv', csvContent, 'text/csv');
  });

  // Add visualization components to the Order API Validator

  // Add tabs for visualizations
  function addVisualizationTabs() {
    // Add new tab to the tab list
    const tabsContainer = document.querySelector('.tabs');
    tabsContainer.innerHTML = `
    <div class="tab active" data-tab="issuesTab">Issues</div>
    <div class="tab" data-tab="visualizationsTab">Visualizations</div>
    <div class="tab" data-tab="recommendationsTab">Recommendations</div>
    <div class="tab" data-tab="exportTab">Export Report</div>
  `;

    // Add visualization tab content
    const resultsSection = document.getElementById('resultsSection');

    // Create visualization tab content
    const visualizationsTab = document.createElement('div');
    visualizationsTab.id = 'visualizationsTab';
    visualizationsTab.className = 'tab-content';
    visualizationsTab.innerHTML = `
    <div class="card mb-4">
      <h3 class="text-xl font-medium mb-4">Issue Distribution</h3>
      <div class="flex flex-wrap">
        <div class="w-full md:w-1/2 p-2">
          <h4 class="font-medium mb-2">By Severity</h4>
          <div id="severityChart" class="chart-container" style="height: 250px;"></div>
        </div>
        <div class="w-full md:w-1/2 p-2">
          <h4 class="font-medium mb-2">By Category</h4>
          <div id="categoryChart" class="chart-container" style="height: 250px;"></div>
        </div>
      </div>
    </div>

    <div class="card mb-4">
      <h3 class="text-xl font-medium mb-4">Order Comparison</h3>
      <div id="orderComparisonChart" class="chart-container" style="height: 300px;"></div>
    </div>

    <div class="card">
      <h3 class="text-xl font-medium mb-4">Common Issues</h3>
      <div id="commonIssuesTable"></div>
    </div>
  `;

    // Insert after issues tab
    const issuesTab = document.getElementById('issuesTab');
    issuesTab.after(visualizationsTab);

    // Reinitialize tab functionality
    initializeTabs();
  }

  // Initialize tab functionality
  function initializeTabs() {
    const tabs = document.querySelectorAll('.tab');
    const tabContents = document.querySelectorAll('.tab-content');

    tabs.forEach(tab => {
      tab.addEventListener('click', () => {
        // Remove active class from all tabs and contents
        tabs.forEach(t => t.classList.remove('active'));
        tabContents.forEach(c => c.classList.remove('active'));

        // Add active class to clicked tab and corresponding content
        tab.classList.add('active');
        const tabId = tab.getAttribute('data-tab');
        document.getElementById(tabId).classList.add('active');
      });
    });
  }

  // Enhanced export functionality
  function enhanceExports() {
    // Add summary section to export tab
    document.getElementById('exportTab').innerHTML = `
    <div class="card mb-4">
      <h3 class="text-xl font-medium mb-4">Export Validation Report</h3>

      <div class="mb-4">
        <div class="flex gap-2 items-center mb-2">
          <i class="fas fa-chart-bar text-primary"></i>
          <span class="font-medium">Validation Summary</span>
        </div>
        <div class="text-sm mb-2">
          <span class="text-gray">Orders Analyzed:</span> ${validationResults.orders.length}
        </div>
        <div class="text-sm mb-2">
          <span class="text-gray">Total Issues:</span> ${validationResults.issues.length}
          (${validationResults.issues.filter(i => i.severity === 'error').length} errors,
          ${validationResults.issues.filter(i => i.severity === 'warning').length} warnings,
          ${validationResults.issues.filter(i => i.severity === 'info').length} suggestions)
        </div>
        <div class="text-sm">
          <span class="text-gray">Top Issue Categories:</span>
          ${getTopCategories(3).map(c => c.name).join(', ') || 'None'}
        </div>
      </div>

      <div class="flex flex-wrap gap-4">
        <button id="exportJsonBtn" class="btn btn-primary">
          <i class="fas fa-file-code"></i> Export as JSON
        </button>
        <button id="exportCsvBtn" class="btn btn-secondary">
          <i class="fas fa-file-csv"></i> Export as CSV
        </button>
        <button id="exportPdfBtn" class="btn btn-secondary">
          <i class="fas fa-file-pdf"></i> Export as PDF
        </button>
        <button id="exportSummaryBtn" class="btn btn-secondary">
          <i class="fas fa-file-alt"></i> Export Summary
        </button>
      </div>
    </div>

    <div class="card">
      <h3 class="text-xl font-medium mb-4">Export Options</h3>

      <div class="mb-4">
        <label class="flex items-center gap-2 mb-2">
          <input type="checkbox" id="includeRecommendations" checked>
          <span>Include Recommendations</span>
        </label>

        <label class="flex items-center gap-2 mb-2">
          <input type="checkbox" id="includeOrderDetails" checked>
          <span>Include Order Details</span>
        </label>

        <label class="flex items-center gap-2">
          <input type="checkbox" id="groupByCategory">
          <span>Group Issues by Category</span>
        </label>
      </div>
    </div>
  `;

    // Set up event listeners for export buttons
    document.getElementById('exportJsonBtn').addEventListener('click', exportAsJson);
    document.getElementById('exportCsvBtn').addEventListener('click', exportAsCsv);
    document.getElementById('exportPdfBtn').addEventListener('click', exportAsPdf);
    document.getElementById('exportSummaryBtn').addEventListener('click', exportSummary);
  }

  // Export as JSON
  function exportAsJson() {
    const includeRecommendations = document.getElementById('includeRecommendations').checked;
    const includeOrderDetails = document.getElementById('includeOrderDetails').checked;

    const exportData = {
      summary: generateExportSummary(),
      timestamp: new Date().toISOString(),
      issues: validationResults.issues
    };

    if (includeRecommendations) {
      exportData.recommendations = validationResults.recommendations;
    }

    if (includeOrderDetails) {
      exportData.orders = validationResults.orders.map(order => ({
        fileName: order.fileName,
        orderNumber: order.orderNumber
      }));
    }

    const data = JSON.stringify(exportData, null, 2);
    downloadFile('order-validation-report.json', data, 'application/json');
  }

  // Export as CSV
  function exportAsCsv() {
    const includeRecommendations = document.getElementById('includeRecommendations').checked;
    const groupByCategory = document.getElementById('groupByCategory').checked;

    // Create CSV for issues
    const headers = ['Severity', 'Title', 'Description', 'Order Number', 'File Name', 'Path', 'Category'];
    const csvRows = [headers];

    // Process issues
    let issues = [...validationResults.issues];

    // Sort by category if needed
    if (groupByCategory) {
      issues.sort((a, b) => {
        const categoryA = getCategoryFromPath(a.path || '');
        const categoryB = getCategoryFromPath(b.path || '');
        return categoryA.localeCompare(categoryB);
      });
    }

    issues.forEach(issue => {
      // Determine category from path
      const category = getCategoryFromPath(issue.path || '');

      csvRows.push([
        issue.severity,
        issue.title,
        issue.description,
        issue.orderNumber,
        issue.fileName,
        issue.path || '',
        category
      ]);
    });

    const csvContent = csvRows.map(row =>
            row.map(cell => `"${(cell || '').toString().replace(/"/g, '""')}"`).join(',')
    ).join('\n');

    downloadFile('order-validation-issues.csv', csvContent, 'text/csv');

    // If recommendations are included, export them as a separate CSV
    if (includeRecommendations) {
      const recHeaders = ['Priority', 'Category', 'Title', 'Description'];
      const recRows = [recHeaders];

      validationResults.recommendations.forEach(rec => {
        // Extract category from ID
        const category = rec.id.split('-')[1];
        const categoryName = categoryNameMap[category] || 'General';

        recRows.push([
          rec.priority,
          categoryName,
          rec.title,
          rec.description
        ]);
      });

      const recCsvContent = recRows.map(row =>
              row.map(cell => `"${(cell || '').toString().replace(/"/g, '""')}"`).join(',')
      ).join('\n');

      downloadFile('order-validation-recommendations.csv', recCsvContent, 'text/csv');
    }
  }

  // Export as PDF (simplified version)
  function exportAsPdf() {
    // This would typically use a library like jsPDF
    // For demo purposes, show a message about PDF generation
    showToast('PDF export would require a PDF generation library');
  }

  // Export summary as text
  function exportSummary() {
    const summary = generateExportSummary();
    const includeRecommendations = document.getElementById('includeRecommendations').checked;

    const summaryText =
            `Order API Validation Summary
===========================

Generated on: ${new Date().toLocaleString()}

Orders Analyzed: ${summary.ordersCount}
Total Issues: ${summary.totalIssues}
  - Critical Issues: ${summary.errorCount}
  - Warnings: ${summary.warningCount}
  - Suggestions: ${summary.infoCount}

Top Issue Categories:
${summary.topCategories.map(c => `  - ${c.name}: ${c.count} issues`).join('\n')}

Health Score: ${summary.healthScore}/100

Issue Rate: ${summary.issueRate.toFixed(2)}%

${includeRecommendations ?
                    `Top Recommendations:
${validationResults.recommendations
                            .filter(rec => rec.priority === 'high')
                            .slice(0, 3)
                            .map(rec => `  - ${rec.title}: ${rec.description}`)
                            .join('\n')}` : ''}
`;

    downloadFile('order-validation-summary.txt', summaryText, 'text/plain');
  }

  // Helper function to get category from path
  function getCategoryFromPath(path) {
    if (path.includes('customer')) {
      return 'Customer Data';
    } else if (path.includes('addresses')) {
      return 'Addressing';
    } else if (path.includes('amounts') || path.includes('pricing')) {
      return 'Financial';
    } else if (path.includes('product') || path.includes('items')) {
      return 'Product Data';
    } else if (path.includes('retailers')) {
      return 'Retailer';
    } else if (path.includes('fulfillment') || path.includes('packages')) {
      return 'Fulfillment';
    } else if (path.includes('options')) {
      return 'Order Options';
    } else {
      return 'Structure';
    }
  }

  // Render charts and visualizations
  function renderVisualizations() {
    renderSeverityChart();
    renderCategoryChart();
    renderOrderComparisonChart();
    renderCommonIssuesTable();
  }

  // Render severity distribution chart (simple CSS-based chart)
  function renderSeverityChart() {
    const errorCount = validationResults.issues.filter(i => i.severity === 'error').length;
    const warningCount = validationResults.issues.filter(i => i.severity === 'warning').length;
    const infoCount = validationResults.issues.filter(i => i.severity === 'info').length;
    const total = errorCount + warningCount + infoCount;

    const errorPercent = total > 0 ? (errorCount / total * 100).toFixed(1) : 0;
    const warningPercent = total > 0 ? (warningCount / total * 100).toFixed(1) : 0;
    const infoPercent = total > 0 ? (infoCount / total * 100).toFixed(1) : 0;

    const chartContainer = document.getElementById('severityChart');

    if (total === 0) {
      chartContainer.innerHTML = `
      <div class="flex flex-col items-center justify-center h-full">
        <i class="fas fa-check-circle text-success" style="font-size: 3rem;"></i>
        <p class="text-center text-gray mt-2">No issues found</p>
      </div>
    `;
      return;
    }

    chartContainer.innerHTML = `
    <div class="bar-chart">
      <div class="chart-bars">
        <div class="chart-bar" style="--bar-value:${errorPercent}%; --bar-color:var(--error);">
          <span class="bar-label">Errors</span>
          <span class="bar-value">${errorCount} (${errorPercent}%)</span>
        </div>
        <div class="chart-bar" style="--bar-value:${warningPercent}%; --bar-color:var(--warning);">
          <span class="bar-label">Warnings</span>
          <span class="bar-value">${warningCount} (${warningPercent}%)</span>
        </div>
        <div class="chart-bar" style="--bar-value:${infoPercent}%; --bar-color:var(--info);">
          <span class="bar-label">Info</span>
          <span class="bar-value">${infoCount} (${infoPercent}%)</span>
        </div>
      </div>
    </div>
  `;
  }

  // Render category distribution chart
  function renderCategoryChart() {
    // Count issues by category
    const categoryCounts = {};

    validationResults.issues.forEach(issue => {
      const path = issue.path || '';
      let category = 'structure';

      if (path.includes('customer')) {
        category = 'customer';
      } else if (path.includes('addresses')) {
        category = 'address';
      } else if (path.includes('amounts') || path.includes('pricing')) {
        category = 'financial';
      } else if (path.includes('product') || path.includes('items')) {
        category = 'product';
      } else if (path.includes('retailers')) {
        category = 'retailer';
      } else if (path.includes('fulfillment') || path.includes('packages')) {
        category = 'fulfillment';
      } else if (path.includes('options')) {
        category = 'options';
      }

      categoryCounts[category] = (categoryCounts[category] || 0) + 1;
    });

    // Sort categories by count
    const sortedCategories = Object.entries(categoryCounts)
            .map(([key, count]) => ({
              key,
              name: categoryNameMap[key] || key,
              count
            }))
            .sort((a, b) => b.count - a.count);

    const chartContainer = document.getElementById('categoryChart');

    if (sortedCategories.length === 0) {
      chartContainer.innerHTML = `
      <div class="flex flex-col items-center justify-center h-full">
        <i class="fas fa-check-circle text-success" style="font-size: 3rem;"></i>
        <p class="text-center text-gray mt-2">No issues found</p>
      </div>
    `;
      return;
    }

    // Calculate percentages
    const total = sortedCategories.reduce((sum, category) => sum + category.count, 0);
    sortedCategories.forEach(category => {
      category.percent = (category.count / total * 100).toFixed(1);
    });

    // Create chart HTML
    chartContainer.innerHTML = `
    <div class="bar-chart">
      <div class="chart-bars">
        ${sortedCategories.map(category => `
          <div class="chart-bar" style="--bar-value:${category.percent}%; --bar-color:var(--primary);">
            <span class="bar-label">${category.name}</span>
            <span class="bar-value">${category.count} (${category.percent}%)</span>
          </div>
        `).join('')}
      </div>
    </div>
  `;
  }

  // Render order comparison chart
  function renderOrderComparisonChart() {
    const orderStats = validationResults.orders.map(order => {
      const orderIssues = validationResults.issues.filter(i => i.orderNumber === order.orderNumber);

      return {
        orderNumber: order.orderNumber,
        fileName: order.fileName,
        errorCount: orderIssues.filter(i => i.severity === 'error').length,
        warningCount: orderIssues.filter(i => i.severity === 'warning').length,
        infoCount: orderIssues.filter(i => i.severity === 'info').length,
        totalCount: orderIssues.length
      };
    });

    // Sort by total issue count
    orderStats.sort((a, b) => b.totalCount - a.totalCount);

    const chartContainer = document.getElementById('orderComparisonChart');

    if (orderStats.length === 0) {
      chartContainer.innerHTML = `
      <div class="flex flex-col items-center justify-center h-full">
        <p class="text-center text-gray">No orders to compare</p>
      </div>
    `;
      return;
    }

    // Create a stacked bar chart
    chartContainer.innerHTML = `
    <div class="stacked-bar-chart">
      ${orderStats.map(stats => `
        <div class="stacked-bar-row">
          <div class="bar-label" title="${stats.fileName}">
            <span class="text-truncate">${stats.orderNumber}</span>
          </div>
          <div class="stacked-bar">
            <div class="stacked-bar-segment" style="--segment-color:var(--error); --segment-width:${stats.errorCount}px;">
              ${stats.errorCount > 0 ? stats.errorCount : ''}
            </div>
            <div class="stacked-bar-segment" style="--segment-color:var(--warning); --segment-width:${stats.warningCount}px;">
              ${stats.warningCount > 0 ? stats.warningCount : ''}
            </div>
            <div class="stacked-bar-segment" style="--segment-color:var(--info); --segment-width:${stats.infoCount}px;">
              ${stats.infoCount > 0 ? stats.infoCount : ''}
            </div>
          </div>
          <div class="bar-total">
            ${stats.totalCount} issues
          </div>
        </div>
      `).join('')}

      <div class="chart-legend">
        <div class="legend-item">
          <span class="legend-color" style="background-color:var(--error);"></span>
          <span>Errors</span>
        </div>
        <div class="legend-item">
          <span class="legend-color" style="background-color:var(--warning);"></span>
          <span>Warnings</span>
        </div>
        <div class="legend-item">
          <span class="legend-color" style="background-color:var(--info);"></span>
          <span>Info</span>
        </div>
      </div>
    </div>
  `;
  }

  // Render common issues table
  function renderCommonIssuesTable() {
    // Group issues by title
    const issueGroups = {};

    validationResults.issues.forEach(issue => {
      if (!issueGroups[issue.title]) {
        issueGroups[issue.title] = {
          title: issue.title,
          severity: issue.severity,
          count: 0,
          orders: new Set()
        };
      }

      issueGroups[issue.title].count++;
      issueGroups[issue.title].orders.add(issue.orderNumber);
    });

    // Convert to array and sort by count
    const commonIssues = Object.values(issueGroups)
            .map(group => ({
              ...group,
              orders: Array.from(group.orders),
              affectedOrdersCount: group.orders.size,
              affectedOrdersPercent: (group.orders.size / validationResults.orders.length * 100).toFixed(0)
            }))
            .sort((a, b) => b.count - a.count);

    const tableContainer = document.getElementById('commonIssuesTable');

    if (commonIssues.length === 0) {
      tableContainer.innerHTML = `
      <div class="flex flex-col items-center justify-center py-6">
        <i class="fas fa-check-circle text-success" style="font-size: 3rem;"></i>
        <p class="text-center text-gray mt-4">No issues found</p>
      </div>
    `;
      return;
    }

    // Create table HTML
    tableContainer.innerHTML = `
    <div class="overflow-x-auto">
      <table class="w-full">
        <thead>
          <tr>
            <th class="text-left py-2">Issue</th>
            <th class="text-center py-2">Severity</th>
            <th class="text-center py-2">Occurrences</th>
            <th class="text-center py-2">Affected Orders</th>
          </tr>
        </thead>
        <tbody>
          ${commonIssues.map((issue, index) => `
            <tr class="${index % 2 === 0 ? 'bg-gray-50' : ''}">
              <td class="py-2 pr-4">${issue.title}</td>
              <td class="text-center">
                <span class="badge badge-${issue.severity}">
                  ${issue.severity.toUpperCase()}
                </span>
              </td>
              <td class="text-center">${issue.count}</td>
              <td class="text-center">
                ${issue.affectedOrdersCount} (${issue.affectedOrdersPercent}%)
              </td>
            </tr>
          `).join('')}
        </tbody>
      </table>
    </div>
  `;
  }

  // Add CSS for charts
  function addChartStyles() {
    const styleElement = document.createElement('style');
    styleElement.textContent = `
    /* Bar Chart Styles */
    .bar-chart {
      width: 100%;
      padding: 20px 0;
    }

    .chart-bars {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }

    .chart-bar {
      display: flex;
      align-items: center;
      width: 100%;
      position: relative;
    }

    .chart-bar::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      height: 100%;
      width: var(--bar-value, 0%);
      background-color: var(--bar-color, #3b82f6);
      opacity: 0.2;
      border-radius: 4px;
      z-index: 0;
    }

    .bar-label {
      width: 80px;
      font-weight: 500;
      z-index: 1;
    }

    .bar-value {
      margin-left: auto;
      font-weight: 600;
      color: var(--bar-color, #3b82f6);
      z-index: 1;
    }

    /* Stacked Bar Chart */
    .stacked-bar-chart {
      width: 100%;
      padding: 20px 0;
    }

    .stacked-bar-row {
      display: flex;
      align-items: center;
      margin-bottom: 15px;
    }

    .stacked-bar {
      display: flex;
      flex: 1;
      height: 30px;
      background-color: #f1f5f9;
      border-radius: 4px;
      overflow: hidden;
    }

    .stacked-bar-segment {
      height: 100%;
      width: var(--segment-width, 0px);
      min-width: var(--segment-width, 0px);
      background-color: var(--segment-color, #3b82f6);
      display: flex;
      justify-content: center;
      align-items: center;
      color: white;
      font-size: 12px;
      font-weight: 600;
    }

    .bar-label {
      width: 150px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      padding-right: 15px;
    }

    .bar-total {
      width: 80px;
      padding-left: 15px;
      font-weight: 500;
    }

    .chart-legend {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-top: 20px;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .legend-color {
      width: 12px;
      height: 12px;
      border-radius: 2px;
    }

    /* Utility for text truncation */
    .text-truncate {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
  `;

    document.head.appendChild(styleElement);
  }

  // Enhance the validation results display
  function enhanceValidationResults() {
    // Add visualization tab
    addVisualizationTabs();

    // Update visualizations
    renderVisualizations();

    // Initialize export options
    initializeExports();

    // Reinitialize filters and interactive elements
    initializeFilters();
  }

  // Initialize interactive filters
  function initializeFilters() {
    // This is a placeholder for any filter initialization
    // This would be implemented for complex filtering options
    console.log('Filters initialized');
  }

  // Show validation settings dialog
  function showValidationSettings() {
    // Create a modal for settings
    const modal = document.createElement('div');
    modal.className = 'validation-settings-modal';
    modal.innerHTML = `
    <div class="modal-content">
      <div class="modal-header">
        <h3 class="text-xl font-bold">Validation Settings</h3>
        <button class="close-btn"><i class="fas fa-times"></i></button>
      </div>
      <div class="modal-body">
        <div class="setting-group">
          <h4 class="font-medium mb-2">Validation Sensitivity</h4>
          <div class="flex items-center mb-4">
            <input type="range" id="sensitivitySlider" min="1" max="3" value="2" class="slider mr-4">
            <div class="text-sm">
              <span id="sensitivityLabel">Normal</span>
            </div>
          </div>
        </div>

        <div class="setting-group">
          <h4 class="font-medium mb-2">Validation Categories</h4>
          <div class="grid grid-cols-2 gap-2">
            <label class="flex items-center">
              <input type="checkbox" checked class="mr-2"> Structure
            </label>
            <label class="flex items-center">
              <input type="checkbox" checked class="mr-2"> Customer Data
            </label>
            <label class="flex items-center">
              <input type="checkbox" checked class="mr-2"> Addressing
            </label>
            <label class="flex items-center">
              <input type="checkbox" checked class="mr-2"> Financial
            </label>
            <label class="flex items-center">
              <input type="checkbox" checked class="mr-2"> Product Data
            </label>
            <label class="flex items-center">
              <input type="checkbox" checked class="mr-2"> Retailer
            </label>
            <label class="flex items-center">
              <input type="checkbox" checked class="mr-2"> Fulfillment
            </label>
            <label class="flex items-center">
              <input type="checkbox" checked class="mr-2"> Order Options
            </label>
          </div>
        </div>

        <div class="setting-group">
          <h4 class="font-medium mb-2">Advanced Options</h4>
          <label class="flex items-center mb-2">
            <input type="checkbox" id="strictMode" class="mr-2"> Strict Validation Mode
          </label>
          <p class="text-sm text-gray mb-4">Enables additional strict validation rules for higher standard compliance</p>

          <label class="flex items-center">
            <input type="checkbox" id="compareOrders" class="mr-2"> Enable Order Comparison
          </label>
          <p class="text-sm text-gray">Compare orders against each other to detect inconsistencies</p>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary mr-2">Reset to Defaults</button>
        <button class="btn btn-primary">Apply Settings</button>
      </div>
    </div>
  `;

    // Add modal styles
    const styleElement = document.createElement('style');
    styleElement.textContent = `
    .validation-settings-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 2000;
    }

    .modal-content {
      background-color: white;
      border-radius: 8px;
      max-width: 600px;
      width: 90%;
      max-height: 90%;
      overflow-y: auto;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem;
      border-bottom: 1px solid var(--gray);
    }

    .modal-body {
      padding: 1.5rem;
    }

    .modal-footer {
      display: flex;
      justify-content: flex-end;
      padding: 1rem;
      border-top: 1px solid var(--gray);
    }

    .close-btn {
      background: none;
      border: none;
      cursor: pointer;
      font-size: 1.25rem;
      color: #64748b;
    }

    .setting-group {
      margin-bottom: 1.5rem;
    }

    .slider {
      -webkit-appearance: none;
      width: 100%;
      height: 8px;
      background: #e2e8f0;
      outline: none;
      border-radius: 4px;
    }

    .slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      background: var(--primary);
      border-radius: 50%;
      cursor: pointer;
    }

    .slider::-moz-range-thumb {
      width: 18px;
      height: 18px;
      background: var(--primary);
      border-radius: 50%;
      cursor: pointer;
    }
  `;

    document.body.appendChild(styleElement);
    document.body.appendChild(modal);

    // Add event listeners
    const sensitivitySlider = document.getElementById('sensitivitySlider');
    const sensitivityLabel = document.getElementById('sensitivityLabel');

    sensitivitySlider.addEventListener('input', () => {
      const value = parseInt(sensitivitySlider.value);

      switch (value) {
        case 1:
          sensitivityLabel.textContent = 'Relaxed';
          break;
        case 2:
          sensitivityLabel.textContent = 'Normal';
          break;
        case 3:
          sensitivityLabel.textContent = 'Strict';
          break;
      }
    });

    // Close button
    const closeBtn = modal.querySelector('.close-btn');
    closeBtn.addEventListener('click', () => {
      document.body.removeChild(modal);
    });

    // Apply button
    const applyBtn = modal.querySelector('.btn-primary');
    applyBtn.addEventListener('click', () => {
      // In a real implementation, this would update validation settings
      document.body.removeChild(modal);

      // Show confirmation
      showToast('Validation settings updated');
    });

    // Reset button
    const resetBtn = modal.querySelector('.btn-secondary');
    resetBtn.addEventListener('click', () => {
      // Reset controls to defaults
      sensitivitySlider.value = 2;
      sensitivityLabel.textContent = 'Normal';
      document.getElementById('strictMode').checked = false;
      document.getElementById('compareOrders').checked = false;

      // Check all category checkboxes
      modal.querySelectorAll('.setting-group:nth-child(2) input[type="checkbox"]').forEach(checkbox => {
        checkbox.checked = true;
      });

      // Show confirmation
      showToast('Settings reset to defaults');
    });
  }

  // Show a toast notification
  function showToast(message) {
    const toast = document.createElement('div');
    toast.className = 'toast';
    toast.innerHTML = `
    <div class="toast-content">
      <i class="fas fa-check-circle mr-2"></i>
      ${message}
    </div>
  `;

    // Add toast styles
    const toastStyles = document.createElement('style');
    toastStyles.textContent = `
    .toast {
      position: fixed;
      bottom: 20px;
      right: 20px;
      padding: 0.75rem 1.5rem;
      background-color: var(--success);
      color: white;
      border-radius: 4px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      z-index: 2000;
      animation: fadeInOut 3s ease-in-out;
    }

    .toast-content {
      display: flex;
      align-items: center;
    }

    @keyframes fadeInOut {
      0% { opacity: 0; transform: translateY(20px); }
      10% { opacity: 1; transform: translateY(0); }
      90% { opacity: 1; transform: translateY(0); }
      100% { opacity: 0; transform: translateY(-20px); }
    }
  `;

    document.body.appendChild(toastStyles);
    document.body.appendChild(toast);

    // Remove toast after animation completes
    setTimeout(() => {
      document.body.removeChild(toast);
      document.body.removeChild(toastStyles);
    }, 3000);
  }

  // Initialize the enhanced validator when the page loads
  document.addEventListener('DOMContentLoaded', initEnhancedValidator);

  // Helper function to download a file
  function downloadFile(filename, content, contentType) {
    const blob = new Blob([content], { type: contentType });
    const url = URL.createObjectURL(blob);

    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }

  // Load demo data for testing
  function loadDemoData() {
    // Example files and data could be loaded here for testing purposes
    console.log('Demo data loaded');
  }

  // Render order data
  // Add this function to your code
  function addOrderViewer() {
    // Check if the tab already exists
    if (document.querySelector('[data-tab="orderViewerTab"]')) {
      return;
    }

    // Add tab
    const viewerTab = document.createElement('div');
    viewerTab.className = 'tab';
    viewerTab.setAttribute('data-tab', 'orderViewerTab');
    viewerTab.textContent = 'Order Data';
    document.querySelector('.tabs').appendChild(viewerTab);

    // Add tab content
    const viewerContent = document.createElement('div');
    viewerContent.className = 'tab-content';
    viewerContent.id = 'orderViewerTab';
    viewerContent.innerHTML = `
      <div class="card">
        <h3 class="text-xl font-medium mb-4">Order Data Viewer</h3>
        <div class="mb-4">
          <label class="text-sm font-medium">Select Order:</label>
          <select id="orderSelector" class="filter-select w-full mt-2">
            ${validationResults.orders.map(order => `
              <option value="${order.orderNumber}">Order #${order.orderNumber}</option>
            `).join('')}
          </select>
        </div>
        <div id="orderDataViewer"></div>
      </div>
    `;
    document.querySelector('.tab-content.active').after(viewerContent);

    // Add event listener to tab
    viewerTab.addEventListener('click', () => {
      // Remove active class from all tabs and contents
      tabs.forEach(t => t.classList.remove('active'));
      document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));

      // Add active class to clicked tab and corresponding content
      viewerTab.classList.add('active');
      viewerContent.classList.add('active');

      // Load first order data
      if (validationResults.orders.length > 0) {
        showOrderDetails(validationResults.orders[0].orderNumber);
      }
    });

    // Add event listener to order selector
    const orderSelector = document.getElementById('orderSelector');
    orderSelector.addEventListener('change', () => {
      showOrderDetails(orderSelector.value);
    });
  }

  // Show order details
  function showOrderDetails(orderNumber, highlightPath = null) {
    const orderData = validationResults.orders.find(order => order.orderNumber === orderNumber)?.data;
    
    if (!orderData) {
      console.error(`Order data not found for order #${orderNumber}`);
      return;
    }

    const orderDataViewer = document.getElementById('orderDataViewer');
    
    // Create summary panels
    const orderInfo = orderData.data || {};
    
    // Basic info
    const basicInfo = `
      <div class="order-card">
        <h4 class="text-lg font-medium mb-2">Basic Information</h4>
        <div class="grid grid-cols-2 gap-4">
          <div>
            <p class="text-sm text-gray">Order Number</p>
            <p class="font-medium">${orderInfo.legacyOrderNumber || 'N/A'}</p>
          </div>
          <div>
            <p class="text-sm text-gray">Date Created</p>
            <p class="font-medium">${formatDate(orderInfo.createdAt) || 'N/A'}</p>
          </div>
          <div>
            <p class="text-sm text-gray">Status</p>
            <p class="font-medium">${orderInfo.status || 'N/A'}</p>
          </div>
          <div>
            <p class="text-sm text-gray">Payment Status</p>
            <p class="font-medium">${orderInfo.paymentStatus || 'N/A'}</p>
          </div>
        </div>
      </div>
    `;

    // Customer info
    const customer = orderInfo.customer || {};
    const customerInfo = `
      <div class="order-card">
        <h4 class="text-lg font-medium mb-2">Customer Information</h4>
        <div class="grid grid-cols-2 gap-4">
          <div>
            <p class="text-sm text-gray">Name</p>
            <p class="font-medium">${customer.firstName || ''} ${customer.lastName || ''}</p>
          </div>
          <div>
            <p class="text-sm text-gray">Email</p>
            <p class="font-medium">${customer.email || 'N/A'}</p>
          </div>
          <div>
            <p class="text-sm text-gray">Phone</p>
            <p class="font-medium">${customer.phone || 'N/A'}</p>
          </div>
        </div>
      </div>
    `;

    // Items summary
    const items = orderInfo.items || [];
    let itemsHtml = '';
    if (items.length > 0) {
      itemsHtml = `
        <div class="order-card">
          <h4 class="text-lg font-medium mb-2">Order Items (${items.length})</h4>
          <div class="space-y-2">
            ${items.map((item, index) => {
              const product = item.product || {};
              return `
                <div class="border rounded p-3">
                  <div class="flex justify-between">
                    <p class="font-medium">${product.name || `Item ${index + 1}`}</p>
                    <p class="font-medium">$${(item.price?.amount || 0).toFixed(2)}</p>
                  </div>
                  <div class="text-sm text-gray flex justify-between mt-1">
                    <span>Qty: ${item.quantity || 0}</span>
                    <span>SKU: ${product.sku || 'N/A'}</span>
                  </div>
                </div>
              `;
            }).join('')}
          </div>
        </div>
      `;
    }

    // Financial summary
    const amounts = orderInfo.amounts || {};
    const financialSummary = `
      <div class="order-card">
        <h4 class="text-lg font-medium mb-2">Financial Summary</h4>
        <div class="space-y-2">
          <div class="flex justify-between">
            <span>Subtotal</span>
            <span>$${(amounts.subtotal?.amount || 0).toFixed(2)}</span>
          </div>
          <div class="flex justify-between">
            <span>Tax</span>
            <span>$${(amounts.tax?.amount || 0).toFixed(2)}</span>
          </div>
          <div class="flex justify-between">
            <span>Shipping</span>
            <span>$${(amounts.shipping?.amount || 0).toFixed(2)}</span>
          </div>
          <div class="flex justify-between font-medium">
            <span>Total</span>
            <span>$${(amounts.total?.amount || 0).toFixed(2)}</span>
          </div>
        </div>
      </div>
    `;

    // Combine panels
    orderDataViewer.innerHTML = `
      <div id="orderSummary">
        ${basicInfo}
        ${customerInfo}
        ${financialSummary}
        ${itemsHtml}
      </div>
      
      <div class="card">
        <h4 class="text-lg font-medium mb-2">Raw Order Data</h4>
        <pre id="jsonTree" class="code"></pre>
      </div>
    `;

    // Create JSON tree viewer
    const jsonTree = document.getElementById('jsonTree');
    jsonTree.innerHTML = formatJSON(orderData, highlightPath);
  }

  // Format date
  function formatDate(dateString) {
    if (!dateString) return '';
    
    try {
      const date = new Date(dateString);
      return date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
    } catch (e) {
      return dateString;
    }
  }

  // Format JSON for display
  function formatJSON(json, highlightPath = null) {
    const jsonString = JSON.stringify(json, null, 2);
    
    if (!highlightPath) {
      return jsonString.replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g, match => {
          let cls = 'json-string';
          if (/^"/.test(match)) {
            if (/:$/.test(match)) {
              cls = 'json-key';
              match = match.replace(/[":]/g, m => m === ':' ? ': ' : m);
            }
          } else if (/true|false/.test(match)) {
            cls = 'json-boolean';
          } else if (/null/.test(match)) {
            cls = 'json-null';
          } else {
            cls = 'json-number';
          }
          return `<span class="${cls}">${match}</span>`;
        });
    } else {
      // Process path for highlighting
      const pathParts = highlightPath.replace(/^data\./, '').split('.');
      let currentObj = json.data;
      let currentPath = 'data';
      let lastArrayIndex = null;
      
      // Handle array indexes in path
      for (let i = 0; i < pathParts.length; i++) {
        const part = pathParts[i];
        
        // Check if it's an array index
        const arrayMatch = part.match(/\[(\d+)\]/);
        if (arrayMatch) {
          const arrayName = part.split('[')[0];
          const index = parseInt(arrayMatch[1]);
          
          currentPath += `.${arrayName}[${index}]`;
          currentObj = currentObj?.[arrayName]?.[index];
          lastArrayIndex = index;
        } else {
          currentPath += `.${part}`;
          currentObj = currentObj?.[part];
          lastArrayIndex = null;
        }
      }
      
      // Highlight specific JSON path
      let found = false;
      return jsonString.replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g, (match, p1, p2, p3, p4, offset) => {
          let cls = 'json-string';
          
          if (/^"/.test(match)) {
            if (/:$/.test(match)) {
              cls = 'json-key';
              const key = match.replace(/[":]$/g, '').replace(/^"/, '');
              
              // Check if this key is part of the path to highlight
              if (pathParts.includes(key) && !found) {
                const preContext = jsonString.substring(0, offset);
                const bracketCount = (preContext.match(/{/g) || []).length - (preContext.match(/}/g) || []).length;
                
                if (bracketCount === pathParts.indexOf(key) + 1) {
                  cls += ' highlight';
                  found = true;
                }
              }
              
              match = match.replace(/[":]/g, m => m === ':' ? ': ' : m);
            }
          } else if (/true|false/.test(match)) {
            cls = 'json-boolean';
          } else if (/null/.test(match)) {
            cls = 'json-null';
          } else {
            cls = 'json-number';
            
            // If we're highlighting an array index
            if (lastArrayIndex !== null && match === lastArrayIndex.toString()) {
              const preContext = jsonString.substring(0, offset);
              const arrayStart = preContext.lastIndexOf('[');
              
              if (arrayStart > -1 && (offset - arrayStart) < 10) {
                cls += ' highlight';
              }
            }
          }
          
          return `<span class="${cls}">${match}</span>`;
        });
    }
  }

  // Helper function to download a file
  function downloadFile(filename, content, contentType) {
    const blob = new Blob([content], { type: contentType });
    const url = URL.createObjectURL(blob);

    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }

  // Load demo data for testing
  function loadDemoData() {
    // Example files and data could be loaded here for testing purposes
    console.log('Demo data loaded');
  }

  // Render order data
  // Add this function to your code
  function addOrderViewer() {
    // Add new tab to the tab list
    const tabsContainer = document.querySelector('.tabs');
    if (!tabsContainer) {
      console.error("Tab container not found");
      return;
    }

    // Check if we already have the Orders tab
    let ordersTabButton = document.querySelector('[data-tab="ordersTab"]');
    if (!ordersTabButton) {
      ordersTabButton = document.createElement('div');
      ordersTabButton.className = 'tab';
      ordersTabButton.setAttribute('data-tab', 'ordersTab');
      ordersTabButton.textContent = 'Orders';
      tabsContainer.appendChild(ordersTabButton);
    }

    // Create orders tab content if it doesn't exist
    let ordersTabContent = document.getElementById('ordersTab');
    if (!ordersTabContent) {
      ordersTabContent = document.createElement('div');
      ordersTabContent.id = 'ordersTab';
      ordersTabContent.className = 'tab-content';

      // Get unique orders to avoid duplicates
      const uniqueOrders = [];
      const orderMap = new Map();

      validationResults.orders.forEach(order => {
        if (!orderMap.has(order.orderNumber)) {
          orderMap.set(order.orderNumber, order);
          uniqueOrders.push(order);
        }
      });

      // Create the structure for order viewer
      ordersTabContent.innerHTML = `
        <div class="card mb-4">
          <h3 class="text-xl font-medium mb-4">Order Details</h3>
          <div class="order-selector mb-4">
            <label for="orderSelector" class="block text-sm font-medium mb-2">Select an order to view</label>
            <select id="orderSelector" class="w-full p-2 border rounded bg-white">
              <option value="">Choose an order...</option>
              ${uniqueOrders.map(order =>
              `<option value="${order.orderNumber}">${order.orderNumber} (${order.fileName})</option>`
      ).join('')}
            </select>
          </div>
          <div id="orderDataViewer">
            <div id="orderSummary" class="mb-4"></div>
            <div id="orderInfoPanels" class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4"></div>
            <div id="orderDetailsContainer"></div>
          </div>
        </div>
      `;

      // Insert into results section
      const resultsSection = document.getElementById('resultsSection');
      if (resultsSection) {
        resultsSection.appendChild(ordersTabContent);
      } else {
        console.error("Results section not found");
        return;
      }

      // Add event listener for order selection
      const orderSelector = document.getElementById('orderSelector');
      if (orderSelector) {
        orderSelector.addEventListener('change', function() {
          const selectedOrderNumber = this.value;
          if (selectedOrderNumber) {
            renderModernOrderData(selectedOrderNumber);
          } else {
            hideOrderViewer();
          }
        });
      }

      // Initialize tab event listeners
      if (ordersTabButton) {
        ordersTabButton.addEventListener('click', function() {
          document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
          document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));

          this.classList.add('active');
          ordersTabContent.classList.add('active');
        });
      }
    }

    // Add styles for order viewer
    addOrderViewerStyles();
  }

  // Hide order viewer when no order is selected
  function hideOrderViewer() {
    const dataViewer = document.getElementById('orderDataViewer');
    if (dataViewer) {
      // Clear content instead of hiding
      const summarySection = document.getElementById('orderSummary');
      const infoPanels = document.getElementById('orderInfoPanels');
      const detailsContainer = document.getElementById('orderDetailsContainer');

      if (summarySection) summarySection.innerHTML = '';
      if (infoPanels) infoPanels.innerHTML = '';
      if (detailsContainer) detailsContainer.innerHTML = '';
    }
  }

  // Render order data in a modern UI format
  function renderModernOrderData(orderNumber) {
    const order = validationResults.orders.find(o => o.orderNumber === orderNumber);
    if (!order) {
      console.error("Order not found:", orderNumber);
      return;
    }

    const summarySection = document.getElementById('orderSummary');
    const infoPanels = document.getElementById('orderInfoPanels');
    const detailsContainer = document.getElementById('orderDetailsContainer');

    if (!summarySection || !infoPanels || !detailsContainer) {
      console.error("Order viewer containers not found");
      return;
    }

    // Extract data from the order
    const data = order.data;
    if (!data) {
      console.error("No data in order:", orderNumber);
      return;
    }

    // Format date properly
    const orderDate = data.createdAt ?
            new Date(data.createdAt).toLocaleDateString('en-US', {
              year: 'numeric',
              month: 'short',
              day: 'numeric'
            }) : 'Unknown';

    const orderStatus = getOrderStatus(data);

    // Format total properly
    const orderTotal = data.amounts?.total ?
            `$${(parseFloat(data.amounts.total) / 100).toFixed(2)}` : 'Unknown';

    const itemCount = data.items?.length || 0;

    // Populate order summary
    summarySection.innerHTML = `
      <div class="stat-card p-3 flex-grow">
        <span class="text-sm text-gray">Order Number</span>
        <div class="text-lg font-bold">${order.orderNumber}</div>
      </div>
      <div class="stat-card p-3 flex-grow">
        <span class="text-sm text-gray">Date</span>
        <div class="text-lg">${orderDate}</div>
      </div>
      <div class="stat-card p-3 flex-grow">
        <span class="text-sm text-gray">Total</span>
        <div class="text-lg font-bold">${orderTotal}</div>
      </div>
      <div class="stat-card p-3 flex-grow">
        <span class="text-sm text-gray">Status</span>
        <div class="text-lg">
          <span class="badge badge-${getStatusColor(orderStatus)}">${orderStatus}</span>
        </div>
      </div>
      <div class="stat-card p-3 flex-grow">
        <span class="text-sm text-gray">Items</span>
        <div class="text-lg">${itemCount}</div>
      </div>
    `;

    // Populate info panels
    infoPanels.innerHTML = '';

    // Customer info panel
    if (data.customer) {
      const customer = data.customer;
      infoPanels.innerHTML += `
        <div class="card p-4">
          <h4 class="text-lg font-medium mb-2">
            <i class="fas fa-user text-primary mr-2"></i> Customer
          </h4>
          <div class="text-sm">
            <div class="mb-1"><strong>Name:</strong> ${customer.firstName || ''} ${customer.lastName || ''}</div>
            <div class="mb-1"><strong>Email:</strong> ${customer.email || 'Not provided'}</div>
            <div class="mb-1"><strong>Phone:</strong> ${customer.phone || data.addresses?.billing?.phone || 'Not provided'}</div>
            ${customer.birthdate ? `<div><strong>DOB:</strong> ${customer.birthdate}</div>` : ''}
          </div>
        </div>
      `;
    }

    // Shipping info panel
    if (data.addresses?.shipping) {
      const shipping = data.addresses.shipping;
      infoPanels.innerHTML += `
        <div class="card p-4">
          <h4 class="text-lg font-medium mb-2">
            <i class="fas fa-shipping-fast text-primary mr-2"></i> Shipping
          </h4>
          <div class="text-sm">
            <div class="mb-1">${shipping.one || ''}</div>
            ${shipping.two ? `<div class="mb-1">${shipping.two}</div>` : ''}
            <div class="mb-1">${shipping.city || ''}, ${shipping.state || ''} ${shipping.zip || ''}</div>
            <div>${shipping.country || ''}</div>
          </div>
        </div>
      `;
    }

    // Financial info panel
    if (data.amounts) {
      const amounts = data.amounts;
      infoPanels.innerHTML += `
        <div class="card p-4">
          <h4 class="text-lg font-medium mb-2">
            <i class="fas fa-money-bill-wave text-primary mr-2"></i> Amounts
          </h4>
          <table class="w-full text-sm">
            <tr>
              <td>Subtotal:</td>
              <td class="text-right">${formatCentsToDollars(amounts.subtotal)}</td>
            </tr>
            <tr>
              <td>Shipping:</td>
              <td class="text-right">${formatCentsToDollars(amounts.shipping)}</td>
            </tr>
            <tr>
              <td>Tax:</td>
              <td class="text-right">${formatCentsToDollars(amounts.tax)}</td>
            </tr>
            ${parseFloat(amounts.discounts || 0) > 0 ? `
            <tr>
              <td>Discounts:</td>
              <td class="text-right">-${formatCentsToDollars(amounts.discounts)}</td>
            </tr>` : ''}
            ${parseFloat(amounts.platform || 0) > 0 ? `
            <tr>
              <td>Platform Fee:</td>
              <td class="text-right">${formatCentsToDollars(amounts.platform)}</td>
            </tr>` : ''}
            <tr class="font-bold border-t border-gray">
              <td>Total:</td>
              <td class="text-right">${formatCentsToDollars(amounts.total)}</td>
            </tr>
          </table>
        </div>
      `;
    }

    // Fulfillment info panel
    const fulfillments = getOrderFulfillments(data);
    if (fulfillments.length > 0) {
      infoPanels.innerHTML += `
        <div class="card p-4">
          <h4 class="text-lg font-medium mb-2">
            <i class="fas fa-box text-primary mr-2"></i> Fulfillment
          </h4>
          <div class="text-sm">
            ${fulfillments.map(f => `
              <div class="mb-2">
                <div><strong>Type:</strong> ${f.type || 'Unknown'}</div>
                <div><strong>Status:</strong> <span class="badge badge-${getFulfillmentStatusColor(f.status)}">${f.status || 'Unknown'}</span></div>
                ${f.packages && f.packages.length ? `
                  <div class="mt-1">
                    <strong>Tracking:</strong> ${f.packages[0].trackingNumber || 'Not available'}
                    ${f.packages[0].carrier ? `(${f.packages[0].carrier})` : ''}
                  </div>
                ` : ''}
              </div>
            `).join('<hr class="my-2">')}
          </div>
        </div>
      `;
    }

    // Items list
    if (data.items && data.items.length > 0) {
      detailsContainer.innerHTML = `
        <h4 class="text-lg font-medium mb-3">Order Items</h4>
        <div class="overflow-x-auto">
          <table class="w-full text-sm">
            <thead>
              <tr class="bg-gray-50 text-left">
                <th class="p-2">Product</th>
                <th class="p-2">Price</th>
                <th class="p-2">Qty</th>
                <th class="p-2 text-right">Total</th>
              </tr>
            </thead>
            <tbody>
              ${data.items.map((item, index) => `
                <tr class="${index % 2 === 0 ? '' : 'bg-gray-50'}">
                  <td class="p-2">
                    <div class="font-medium">${item.product?.name || 'Unknown Product'}</div>
                    <div class="text-xs text-gray">${item.product?.size || ''}</div>
                    ${item.customerPlacement ? `<div class="text-xs text-primary">Type: ${capitalizeFirstLetter(item.customerPlacement)}</div>` : ''}
                  </td>
                  <td class="p-2">${formatCentsToDollars(item.pricing?.unitPrice)}</td>
                  <td class="p-2">${item.pricing?.quantity || 1}</td>
                  <td class="p-2 text-right">${formatCentsToDollars(item.pricing?.price)}</td>
                </tr>
              `).join('')}
            </tbody>
          </table>
        </div>
      `;
    } else {
      detailsContainer.innerHTML = '<p class="text-sm text-gray">No items in this order</p>';
    }

    // Highlight issues related to this order
    highlightRelevantIssues(orderNumber);
  }

  // Helper function to get the order status
  function getOrderStatus(data) {
    if (!data) return 'Unknown';

    // Try to determine status from fulfillments
    if (data.retailers && Array.isArray(data.retailers)) {
      const fulfillments = data.retailers.flatMap(r => r.fulfillments || []);
      if (fulfillments.length > 0) {
        const statuses = fulfillments.map(f => f.status);
        if (statuses.includes('delivered')) return 'Delivered';
        if (statuses.includes('shipped')) return 'Shipped';
        if (statuses.includes('processing')) return 'Processing';
        if (statuses.includes('pending')) return 'Pending';
        return statuses[0] || 'Pending';
      }
    }

    // Fallback
    return 'Pending';
  }

  // Helper function to format cents to dollars
  function formatCentsToDollars(cents) {
    if (cents === undefined || cents === null) return '$0.00';
    return `$${(parseFloat(cents) / 100).toFixed(2)}`;
  }

  // Helper function to capitalize first letter
  function capitalizeFirstLetter(string) {
    if (!string) return '';
    return string.charAt(0).toUpperCase() + string.slice(1).replace('_', ' ');
  }

  // Helper functions
  function formatAmount(amount) {
    if (amount === undefined || amount === null) return '$0.00';
    return `$${parseFloat(amount).toFixed(2)}`;
  }

  ////
  function getOrderStatus(data) {
    if (!data) return 'Unknown';

    // Try to determine status from fulfillments
    if (data.retailers && Array.isArray(data.retailers)) {
      const fulfillments = data.retailers.flatMap(r => r.fulfillments || []);
      if (fulfillments.length > 0) {
        const statuses = fulfillments.map(f => f.status);
        if (statuses.includes('delivered')) return 'Delivered';
        if (statuses.includes('shipped')) return 'Shipped';
        if (statuses.includes('processing')) return 'Processing';
        if (statuses.includes('pending')) return 'Pending';
        return statuses[0] || 'Pending';
      }
    }

    // Fallback
    return 'Pending';
  }

  function getStatusColor(status) {
    switch (status.toLowerCase()) {
      case 'delivered': return 'success';
      case 'shipped': return 'info';
      case 'processing': return 'warning';
      case 'pending': return 'warning';
      case 'cancelled': return 'error';
      default: return 'info';
    }
  }

  function getFulfillmentStatusColor(status) {
    return getStatusColor(status);
  }

  function getOrderFulfillments(data) {
    if (!data || !data.retailers) return [];

    let fulfillments = [];
    data.retailers.forEach(retailer => {
      if (retailer.fulfillments && Array.isArray(retailer.fulfillments)) {
        fulfillments = fulfillments.concat(retailer.fulfillments);
      }
    });

    return fulfillments;
  }

  // Update styles for the modern UI
  function addOrderViewerStyles() {
    // Check if styles are already added
    if (document.getElementById('orderViewerStyles')) {
      return;
    }

    const styleEl = document.createElement('style');
    styleEl.id = 'orderViewerStyles';
    styleEl.textContent = `
    #orderDataViewer {
      margin-top: 1rem;
    }

    #orderSummary {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      margin-bottom: 1.5rem;
    }

    #orderSummary .stat-card {
      background-color: #f8fafc;
      border-radius: 0.375rem;
      flex: 1;
      min-width: 120px;
      padding: 1rem;
    }

    #orderInfoPanels {
      margin-bottom: 1.5rem;
    }

    .order-card {
      background-color: white;
      border-radius: 0.5rem;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      padding: 1.5rem;
      margin-bottom: 1rem;
    }

    .table-container {
      overflow-x: auto;
      margin-bottom: 1.5rem;
    }

    table {
      border-collapse: collapse;
      width: 100%;
    }

    table td, table th {
      padding: 0.5rem;
      text-align: left;
    }

    table tr.bg-gray-50 {
      background-color: #f8fafc;
    }

    .highlighted-issue {
      border-left: 4px solid var(--primary);
      background-color: rgba(59, 130, 246, 0.05);
    }
    `;
    document.head.appendChild(styleEl);
  }

  // Fix the integration with enhanceValidationResults
  // Move this to the top of your script, just after the variable declarations
  function setupOrderViewerIntegration() {
    // Store the original function reference if it exists
    if (typeof window.enhanceValidationResults === 'function') {
      const originalEnhanceValidationResults = window.enhanceValidationResults;

      // Override the function
      window.enhanceValidationResults = function() {
        // Call the original function
        originalEnhanceValidationResults.call(this);

        // Add order viewer
        console.log("Adding order viewer after enhanceValidationResults");
        addOrderViewer();
      };
      console.log("enhanceValidationResults function hooked");
    } else {
      console.log("enhanceValidationResults not available yet, will try later");
      // Function doesn't exist yet, set up a MutationObserver to catch when results appear
      const observer = new MutationObserver(function(mutations) {
        if (document.getElementById('resultsSection') && !document.getElementById('resultsSection').classList.contains('hidden')) {
          console.log("Results detected, adding order viewer");
          addOrderViewer();
          observer.disconnect();
        }
      });

      observer.observe(document.body, { childList: true, subtree: true });
    }
  }

  // Highlight issues related to the current order
  function highlightRelevantIssues(orderNumber) {
    // Reset all issues
    document.querySelectorAll('#issuesTab .issue').forEach(issue => {
      issue.classList.remove('highlighted-issue');
    });

    if (!orderNumber) return;

    // Highlight issues for this order
    document.querySelectorAll('#issuesTab .issue').forEach(issue => {
      const textContent = issue.querySelector('.text-sm')?.textContent;
      if (textContent && textContent.includes(`Order: ${orderNumber}`)) {
        issue.classList.add('highlighted-issue');
      }
    });
  }

  // Initialize the enhanced validator
  function initEnhancedValidator() {
    // Set up event listeners for export buttons
    exportJsonBtn.addEventListener('click', exportJsonReport);
    exportCsvBtn.addEventListener('click', exportCsvReport);
    
    // Set default order number for testing
    orderNumbersTextarea.value = "1743175238931";
    updateOrderList();
    
    // Add any other initialization code here
  }

  // Export validation report as JSON
  function exportJsonReport() {
    const report = {
      generated: new Date().toISOString(),
      summary: {
        totalOrders: validationResults.orders.length,
        totalIssues: validationResults.issues.length,
        issuesBySeverity: {
          error: validationResults.issues.filter(i => i.severity === 'error').length,
          warning: validationResults.issues.filter(i => i.severity === 'warning').length,
          info: validationResults.issues.filter(i => i.severity === 'info').length
        }
      },
      orders: validationResults.orders.map(order => ({
        orderNumber: order.orderNumber,
        issues: validationResults.issues.filter(i => i.orderNumber === order.orderNumber).map(issue => ({
          severity: issue.severity,
          title: issue.title,
          description: issue.description,
          path: issue.path
        }))
      })),
      recommendations: validationResults.recommendations
    };

    downloadFile('order-validation-report.json', JSON.stringify(report, null, 2), 'application/json');
  }

  // Export validation report as CSV
  function exportCsvReport() {
    // Create CSV header
    const header = ['Order Number', 'Severity', 'Title', 'Description', 'Path'];
    
    // Create rows
    const rows = validationResults.issues.map(issue => [
      issue.orderNumber,
      issue.severity,
      issue.title,
      issue.description,
      issue.path
    ]);
    
    // Combine header and rows
    const csvContent = [
      header.join(','),
      ...rows.map(row => row.map(cell => {
        // Escape commas and quotes in cells
        const cellContent = String(cell || '');
        if (cellContent.includes(',') || cellContent.includes('"') || cellContent.includes('\n')) {
          return `"${cellContent.replace(/"/g, '""')}"`;
        }
        return cellContent;
      }).join(','))
    ].join('\n');
    
    downloadFile('order-validation-report.csv', csvContent, 'text/csv');
  }

  // Helper functions for showing/hiding error messages
  function showErrorMessage(message) {
    const errorMessageElement = document.getElementById('errorMessage');
    const errorMessageText = document.getElementById('errorMessageText');
    
    errorMessageText.textContent = message;
    errorMessageElement.classList.remove('hidden');
  }
  
  function hideErrorMessage() {
    const errorMessageElement = document.getElementById('errorMessage');
    errorMessageElement.classList.add('hidden');
  }
</script>

</body>
</html>
